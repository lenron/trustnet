<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Crypto Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>


	<div>
	   <h1>Hex64 Decode/Encode</h1>
	</div>
	<div id='encode64pane'>
		<div style="display: flex; flex-direction: column; border-style: inset;">
			<div style="display: flex;">
				<div style="display: flex; flex-direction: column;">
					<label>Raw:</label>
					<input id="raw_64encode_text" style="width: 400px;"></input>
				</div>
				<div>
					<span style='font-size:40px; margin: 4px;'>&#8680;</span>
				</div>
				<div style="display: flex; flex-direction: column;">
					<label>64 Encoded:</label>
					<input id="encoded64_text" style="width: 400px;"></input>
				</div>
			</div>
			<button id='encode64' onclick="encode64()" style="width: 80px">Encode 64</button>
		</div>
		<br>
		<div style="display: flex; flex-direction: column; border-style: inset;">
			<div style="display: flex;">
				<div style="display: flex; flex-direction: column;">
					<label>64 Encoded:</label>
					<input id="raw_64encoded_text" style="width: 400px;"></input>
				</div>
				<div>
					<span style='font-size:40px; margin: 4px;'>&#8680;</span>
				</div>
				<div style="display: flex; flex-direction: column;">
					<label>64 Decoded:</label>
					<input id="decoded64_text" style="width: 400px;"></input>
				</div>
			</div>
			<button id='decode64' onclick="decode64()" style="width: 100px">Decode 64</button>
		</div>
	</div>


	<div>
	   <h1>Setup AES-256-CBC</h1>
	</div>
	<div id='encrypt_pane' style="display: flex; flex-direction: column; border-style: inset;">

		<div style="display: flex; flex-direction: row;">
			<div style="margin: 5px;"> 
				<div style="display: flex; flex-direction: column;">
					<div style="display: flex; flex-direction: column;">
						<label>Password:</label>
						<input id="enter_password" style="width: 200px;"></input>
					</div>
					<div style="display: flex; flex-direction: column;">
						<label>Iterations:</label>
						<input id="enter_iterations" style="width: 200px;"></input>
					</div>
					<div style="display: flex; flex-direction: column;">
						<label>Hash:</label>
						<input id="enter_hash" style="width: 200px;" value="SHA-256"></input>
					</div>
					<div style="display: flex;">
						<div style="display: flex; flex-direction: column;">
							<label>Salt(hex):</label>
							<input id="enter_salt" style="width: 200px;"></input>
						</div>
					</div>
				</div>
			</div>
			<div style="margin: 5px;"> 
				<div style="display: flex; flex-direction: column; height: 100%;">
					<div style="display: flex; flex-direction: column;">
						<label>Plaintext:</label>
						<input id="enter_plaintext" style="width: 400px;"></input>
					</div>
					<div style="display: flex;">
						<div style="display: flex; flex-direction: column;">
							<label>Initialization Vector (IV) (hex):</label>
							<input id="enter_iv" style="width: 400px;"></input>
						</div>
					</div>
					<div style="display: flex; height: 100%; width: 100%; flex-direction: column; justify-content: center; align-items: center;">
						<button id='gen_iv' onclick="genSaltIv()" style="width: 200px">Generate Salt & IV</button>
					</div>
				</div>
			</div> 
		</div>
		<div style="display: flex; flex-direction: column; margin: 5px;">
			<label>Key Data - deriveBits:</label>
			<input id='key_output_derive' style="width: 600px;">
		</div>
		<div style="display: flex; flex-direction: column; margin: 5px;">
			<label>Key Data - exportKey:</label>
			<input id='key_output_export' style="width: 600px;">
		</div>
		<div style="display: flex; flex-direction: column; margin: 5px;">
			<label>Key Data - Key + IV:</label>
			<input id='key_output_full' style="width: 600px;">
		</div>
		<div style="display: flex; flex-direction: column; margin: 5px;">
			<label>Key Data - Key:</label>
			<input id='key_output_key' style="width: 600px;">
		</div>
		<div style="display: flex; flex-direction: column; margin: 5px;">
			<label>Key Data - IV:</label>
			<input id='key_output_iv' style="width: 600px;">
		</div>
<br>
		<div>
			<button id='encrypt_cbc' onclick="encryptCbc()" style="background-color: lightgreen; width: 200px; margin: 5px;">Encrypt AES-256-CBC</button>
		</div>
		<div style="display: flex; flex-direction: column; margin: 5px;">
			<label>Encrypted Output:</label>
			<input id='encrypted_output' style="width: 600px;">
		</div>
		<div style="display: flex; flex-direction: column; margin: 5px;">
			<label>Encrypted Output (base 64):</label>
			<input id='encrypted_output64' style="width: 600px;">
		</div>
		<div style="display: flex; flex-direction: column; margin: 5px;">
			<label>Encrypted Output (base 64 direct function):</label>
			<input id='encrypted_output64_function' style="width: 600px;">
		</div>
		<div style="display: flex; flex-direction: column; margin: 5px;">
			<label>Openssl Output:</label>
			<input id='openssl_output' style="width: 600px;">
		</div>
	</div>

</body>
</html>
<script>

	function getKeyMaterial() {
		const password = document.getElementById("enter_password").value;
		const enc = new TextEncoder();
		return window.crypto.subtle.importKey(
			"raw",
			enc.encode(password),
			"PBKDF2",
			false,
			["deriveBits", "deriveKey"],
		);
	}

	async function encryptCbc() {
		const plaintext = document.getElementById("enter_plaintext").value;
		const inputtext_encoded = new TextEncoder().encode( plaintext );
//var plaintextbytes=new Uint8Array(inputtext_encoded);
var inputbytes = new Uint8Array(inputtext_encoded);
let single_newline = new Uint8Array(1);
single_newline[0] = 10;
const plaintextbytes_buf = concatBuffer(inputbytes, single_newline);
let plaintextbytes = new Uint8Array(plaintextbytes_buf);
const decoder = new TextDecoder();
const input_string = decoder.decode(plaintextbytes);
console.log("plaintext: " + input_string);

const plaintext64 = _arrayBufferToBase64(plaintextbytes);
console.log("plaintext 64: " + plaintext64);
console.log(plaintextbytes);
		const salt_in = document.getElementById("enter_salt").value;
		const iv_in = document.getElementById("enter_iv").value;
		const iter = Number(document.getElementById("enter_iterations").value);
		const digest_hash = document.getElementById("enter_hash").value;

		// Automatically generate Salt & IV if neither is provided.
		if( !(salt_in || iv_in) ){
			genSaltIv();
		}
		salt = hex2buf(document.getElementById("enter_salt").value);
		iv = hex2buf(document.getElementById("enter_iv").value);

		const keyMaterial = await getKeyMaterial();

		// Show the derived bits
		const derived_bits = await window.crypto.subtle.deriveBits(
			{
				name: "PBKDF2",
				salt,
				iterations: iter,
				hash: digest_hash,
			},
			keyMaterial,
			384,
		);
		const derivedKeyBuffer = new Uint8Array(derived_bits);
		const full_key = buf2hex(derivedKeyBuffer);
		document.getElementById("key_output_full").value = full_key.toUpperCase();

		const keybytes = derivedKeyBuffer.slice(0, 32);
		const ivbytes = derivedKeyBuffer.slice(32);
		const key_key = buf2hex(keybytes);
		const key_iv = buf2hex(ivbytes);
		document.getElementById("key_output_key").value = key_key.toUpperCase();
		document.getElementById("key_output_iv").value = key_iv.toUpperCase();

		let key = await window.crypto.subtle.importKey(
			'raw', 
			keybytes, 
			{
				name: 'AES-CBC', 
				length: 256
			}, 
			false, 
			['encrypt']
		);
		//const encrypted_result = await window.crypto.subtle.encrypt({ name: "AES-CBC", iv: ivbytes }, key, inputtext_encoded);
		const encrypted_result = await window.crypto.subtle.encrypt({ name: "AES-CBC", iv: ivbytes }, key, plaintextbytes);

		//var cipherbytes=await window.crypto.subtle.encrypt({name: "AES-CBC", iv: ivbytes}, key, plaintextbytes)
/*
		const dec = new TextDecoder();
		const encrypted_string = dec.decode(encrypted_result);
*/
		cipherbytes = new Uint8Array(encrypted_result);
		let encrypted_string = _arrayBufferToBase64(cipherbytes);
		document.getElementById("encrypted_output").value = encrypted_string;
		//const encrypted64 = btoa( encrypted_string );
		//document.getElementById("encrypted_output64").value = encrypted64;

		const const_salt = "Salted__";
		const salt64 = new TextEncoder().encode(const_salt);
		// Convert only the encrypted message to base 64.
		const result = _arrayBufferToBase64(encrypted_result); 
		document.getElementById("encrypted_output64_function").value = result;

		// Combine constant salt, random salt, and encrypted result as array buffers,
		// then convert to base64.
		const two_salts = concatBuffer(salt64, salt);
		const output = concatBuffer(two_salts, cipherbytes);
		const out64 = _arrayBufferToBase64(output);
		document.getElementById("openssl_output").value = out64;



/*
		const const_salt = "Salted__";
		const magic_salt = btoa( const_salt );
		const salt64 = _arrayBufferToBase64(salt);
		const result = _arrayBufferToBase64(encrypted_result); 
		document.getElementById("encrypted_output").value = result;
		document.getElementById("openssl_output").value = magic_salt + salt64  + result;

???END
		const result = buf2hex(encrypted_result); 
		document.getElementById("encrypted_output").value = result;
		document.getElementById("openssl_output").value = "Salted__" + result;
*/
	}

function concatBuffer(buffer1, buffer2) {
  var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
  tmp.set(new Uint8Array(buffer1), 0);
  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
  return tmp.buffer;
};



function _arrayBufferToBase64( buffer ) {
    var binary = '';
    var bytes = new Uint8Array( buffer );
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode( bytes[ i ] );
    }
    return window.btoa( binary );
}

	function genSaltIv(){
		var iv = crypto.getRandomValues(new Uint8Array(16));
		document.getElementById("enter_iv").value = buf2hex(iv).toUpperCase();	
		var salt = crypto.getRandomValues(new Uint8Array(8));
		document.getElementById("enter_salt").value = buf2hex(salt).toUpperCase();	
	}

	function buf2hex(buffer) { // buffer is an ArrayBuffer
		return [...new Uint8Array(buffer)]
			.map(x => x.toString(16).padStart(2, '0'))
			.join('');
	}
	 // This function converts a hex string into an ArrayBuffer for hash processing.
	function hex2buf(hexString){
		// convert to a number array representing the hex bytes.
		const hexBytesArray = new Array;
		for(var i=0; i < hexString.length; i+=2){
			hexBytesArray.push(parseInt(hexString.substring(i, i+2), 16));
		}
		const hexArrayBuffer = new Uint8Array(hexBytesArray);
		return hexArrayBuffer;
	}


	function encode64(){
		let raw_text = document.getElementById("raw_64encode_text").value;
		console.log("Encoding the string: '" + raw_text + "'");
		const encoded64 = btoa(raw_text);
		console.log("Encoded string: '" + encoded64 + "'");
		document.getElementById("encoded64_text").value = encoded64;
		document.getElementById("raw_64encoded_text").value = encoded64;
	}

	function decode64(){
		let decoded_text = document.getElementById("raw_64encoded_text").value;
		console.log("Decoding the string: '" + decoded_text + "'");
		const decoded64 = atob(decoded_text);
		console.log("Decoded string: '" + decoded64 + "'");
		document.getElementById("decoded64_text").value = decoded64;
	}

</script>






