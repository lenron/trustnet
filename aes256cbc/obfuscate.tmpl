<!DOCTYPE HTML>
<html>
<meta content="text/plain;charset=utf-8" http-equiv="Content-Type" />
<meta content="utf-8" http-equiv="encoding" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<head>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap" rel="stylesheet">
</head>
<style>

	* {
	  font-family: "Orbitron", serif;
	  font-optical-sizing: auto;
	  font-weight: 600;
	  font-style: normal;
	}

	html {
		background-color: #272727;
	}

	body {
		display: flex;
		flex-direction: column;
		min-height: 100vh;
		margin: 0;
		padding: 0;
	}

	.header {
		display: flex;
		flex-direction: row;
		justify-content: space-between;
		align-items: center;
		color: #54c597;
		padding: 4px;
		padding-right: 10px;
		padding-left: 10px;
	}

	.header_content {
		display: flex;
	}

	.header_title {

	}

	.header_label {
		padding: 8px;
	}

	.center_html {
		width: 100%;
		background-color: #272727;
		flex: 1 auto;
		display: flex;
		/*align-self: center;*/
	}

	.content_html {
		width: 100%;
		display: flex;
		/*align-items: baseline;*/
		justify-content: center;
	}

	/* generated conetent */
	.gen {
		width: 700px;
		margin: 10px;
		align-self: center;
		display: flex;
		flex-direction: column;
		justify-content: center; 
		color: #54c597;
	}

	/* default button styling. HTML style="" will override. */
	button {
		/*width: 400px;*/
		height: 65px;
		background-color: #434343;
		border: 2px solid;
		padding: 2px;
		margin: 8px;
		padding-right: 10px;
		padding-left: 10px;
		color: #54c597;
		border-color: #54c597;
		font-size: 17px;
		border-radius: 15px;
	}

	input {
		height: 80px;
		width: 95%;
		background-color: #272727;
		border: 2px solid;
		padding: 8px;
		margin: 8px;
		border-color: #54c597;
		color: #54c597;
		font-size: 25px;
		border-radius: 20px;
	}

	textarea {
		/*width: 600px;*/
		width: 95%;
		height: 150px;
		background-color: #272727;
		border: 2px solid;
		padding: 12px;
		margin: 8px;
		border-color: #54c597;
		color: #54c597;
		font-size: 25px;
		border-radius: 30px;
	}

	/* 'Are you sure?' overlay */
	.deletecheck {
		justify-content:center;
		align-items:center;
		z-index:10;
		position:absolute;
		width:100%;
		height:215%;
		display:none;
		background-color:gray;
		padding:8px;
		margin-left:0;
		margin-top:-40%;
		flex-direction: column;
		border:2px solid;
		border-color:red; 
		border-radius:30px;
	}

	/* Add this class to a span or label (and other types?) to make it a cool looking pink */
	.coolpink {
		color:#ff00ff;
		text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
	}

	/* Set minimum page Width to */
	@media screen and (max-width: 340px){ html,body {min-width: 340px} }

	/* Set minimum page Height to 400 */
	@media screen and (max-height: 400px){ html,body {min-height: 400px} }	

	/* Responsive Design: When the viewport is fewer than 700px wide, activate the following CSS. */
	@media screen and (max-width:700px) {

		input {
			width: 90%;
		}

		textarea {
			width: 90%;
		}

		.header {
			flex-direction: column;
		}

		.home button {
			width: 200px;
			/*border-color: black;*/
		}

		.home_buttons {
			/*flex-direction: column;*/
		}

		.choose button {
			font-size: 14px;
		}

		.upload input {
			font-size: 16px;
		}

		.deletecheck {
			margin-top: -50%;
			height: 220%;
		}
		
		.content_html {
			margin-top: -100px;
		}
	}
	@media screen and (max-width:500px) {
/*
		input {
			width: 400px;
		}

		textarea {
			width: 400px;
		}
*/
		.home button {
			width: 150px;
			font-size: 14px;
			/*border-color: black;*/
		}

		.deletecheck {
			width: 95%;
			margin-top: -75%;
			height:250%;
		}
	}



</style>
<body>

	<div class="header" id="header">
		<div class="header_content" id="header_left">
			<div class="header_title">
				<h1 id="titletext">SECRETWORD</h1>
			</div>
		</div>
		<div class="header_content" id="header_right">
			<div class="header_label" style="">
				<label id="howworks">HOW IT WORKS</label>
			</div>
			<div class="header_label" style="">
				<label id="faq">FAQ</label>
			</div>
		</div>
	</div>
	<div class="offline_ui_inform" style="display:flex; justify-content:flex-end;">
		<label id="offline_label">YOU'RE OFFLINE. SERVER WILL NOT BE UPDATED WITH ANY NEW SAVES.</label>
	</div>
	<div class="center_html" id="center_html">
		<div class="content_html" id="content_html">

			<TMPL_VAR NAME=htmlblock>

		</div>
	</div>
	<div style="display:flex; flex-direction:column;">
		<button id="connect_dbase_button" style="display:none; flex-grow:1" onclick="createNewOfflineDBase()">ACTIVATE SERVER BACKUP OF OFFLINE DATABASE</button>
		<div style="display:flex">
			<button id="toggle_debug_button" style="flex-grow:1" onclick="toggleDebug()">SWITCH TO DEBUG MODE</button>
			<button id="download_offline_dbase_button" style="flex-grow:1" onclick="saveOfflineDBase()">DOWNLOAD STANDALONE.HTML</button>
			<button id="access_offline_dbase_button" style="flex-grow:1" onclick="accessExistingOfflineDBase()">ACCESS OFFLINE DBASE</button>
		</div>
	</div>

	<div id="overlay_get_new_fingerprint" style="display:none; justify-content:center; align-items:center; z-index:10; position:absolute; width:100%; height:100%; flex-direction:column; background-color:white;">
		<h2 id="store_offline_dbase_label">You've successfully stored data to your user-specific Offline Database. If you would like to save it to the server, please enter passwords and hit SUBMIT. If not, hit CANCEL.</h2>
		<h2 id="load_offline_dbase_label">ENTER PASSWORDS TO ACCESS OFFLINE DATABASE</h2>
		<div style="display:flex; flex-direction:column;">
			<input autocomplete="off" type="password"  value="" id="new_fingerprint_1" style="">
			<input autocomplete="off" type="password"  value="" id="new_fingerprint_2" style="">
			<input autocomplete="off" type="password"  value="" id="new_fingerprint_3" style="">
		</div>
		<div style="display:flex; flex-direction:row;">
			<button id="continue_new_fingerprint" style="">SUBMIT PASSWORDS</button>
			<button id="cancel_new_fingerprint" style="">CANCEL</button>
		</div>
	</div>

	<!-- Default Offline Database. Access with 4x 'secret' --!>
	<p id="offline_dbase" style="display:none">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</p>
	<p id="offline_dbase_fingerprint" style="display:none"></p>

</body>
<script>

	// Set Title to link to Home.
	document.getElementById("titletext").onclick = function() {
		location.href = "https://chat.dance/obf";
	}
	// later
	document.getElementById("howworks").onclick = function() {
		location.href = "https://chat.dance/obf/how";
		// howworks();
	}
	// later
	document.getElementById("faq").onclick = function() {
		location.href = "https://chat.dance/obf/faq";
		// faq();
	}

	// global flags 
	let upload_flag = 'false';
	let download_flag = 'false';
	let save_location_thread_flag = 'false';
	let special_button_flag = 'false';
	let current_save_location;

	// Base 58 character map.
	const base58map = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

	//////////////////////////////////////////////////////////////
	//		UI & Threadwalker Handler Functions					//
	//////////////////////////////////////////////////////////////
	// Show target page. 
	// Input: Target is the element ID of an html generated pane.
	function showPage(target){
		// Hide all password warnings.
		pass_warn_elements = document.getElementsByClassName('pass_length_warn');
		for (let i = 0; i < pass_warn_elements.length; i++) {
			pass_warn_elements[i].style.display = "none";
		}

		let generated_html_pages;
		// Fill generated_html_pages array with set of objects (divs in this case) that are tagged as generated html.
		generated_html_pages = document.getElementsByClassName('gen');
		// hide all generated_html_pages
		for (let i = 0; i < generated_html_pages.length; i++) {
			generated_html_pages[i].style.display = "none";
		}
		// show target 
		document.getElementById(target).style.display = "flex";
		// focus input or textbox
		let inputs_array = document.getElementById(target).getElementsByTagName('input');
		let textareas_array = document.getElementById(target).getElementsByTagName('textarea');
		// There is only 1 input or 1 textarea per div in our setup.
		// If we found more than zero inputs in the array, focus the first and only one.
		if( inputs_array.length > 0 ){
			inputs_array[0].focus();
		}
/*
		// Otherwise, we should find 1 textarea to focus if we need to focus anything.
		 else if( textareas_array.length > 0 ){
			 textareas_array[0].focus();
		 }
*/
	}

	// Used to check password length as user flows through interface.
	// Inputs: input_div is
	// 		   next_div is the id of the next page in the thread which will be accessed if the password length is validated.
	// Output: Warns user and doesn't pass if length outside constraints.
	function checkPassLength(current_div, next_div){
		// Get all inputs in the active user-shown div (should only be 1).
		let input_array = document.getElementById(current_div).getElementsByTagName('input');
		if( input_array.length > 1 ){
			throw new Error('More than 1 input found in active div. This should never trigger.');
		}
		// Get the current length of the value in the password/codeword field.
		let length = input_array[0].value.length;
		// Change global password length constraints here.
		// Start at 1 to catch empty passowords/codeword. Can change later.
		if( length < 1 ){
			// Activate text informing user of error.
			//document.getElementById("password_length_warning").style.display = "inline";
			
			// Show all password warnings.
			pass_warn_elements = document.getElementsByClassName('pass_length_warn');
			for (let i = 0; i < pass_warn_elements.length; i++) {
				pass_warn_elements[i].style.display = "inline";
			}
		}else{
			// User may access next function.
			if( next_div === 'executeStore' ){
				storeExecute();
			}else if( next_div === 'executeLoad' ){
				loadExecute();
			}else{
				showPage(next_div);
			}
		}
	}

	// Clears all fields that could contain sensitive data.
	// Resets delete overlay
	function securityReset(){
		console.log("CLEARING FIELDS FOR SECURITY-- SECURITY RESET ENABLED");
		// Reset delete overlay
		deleteCheckHide('overlay_text');
		deleteCheckHide('overlay_download');
		// Clear store fields
		document.getElementById("store_data").value = '';
		document.getElementById("upload_data").value = '';
		document.getElementById("store_codeword").value = '';
		document.getElementById("store_pass_1").value = '';
		document.getElementById("store_pass_2").value = '';
		document.getElementById("store_pass_3").value = '';
		// Clear load
		document.getElementById("load_codeword").value = '';
		document.getElementById("load_pass_1").value = '';
		document.getElementById("load_pass_2").value = '';
		document.getElementById("load_pass_3").value = '';
		// Clear output display
		document.getElementById("output_display").value = '';
		// Reset download flag
		download_flag = 'false';

		// These needs to be set in case the user wanders from the path.	
		save_location_thread_flag = 'false';
		current_save_location = '';
		special_button_flag = 'false';
		setSaveLocationUI();
		//informOfflineStatus();
		updateOnlineStatus();
	}
/*
	function informOfflineStatus(){
		//
		if( navigator.onLine ){
			console.log("Navigator is returning ONLINE status.");
		} else {
			console.log("Navigator is OFFLINE!");
		}
	}
*/
	function setSaveLocationUI(){
		// Show or Hide Special Store Thread UI indicator
		if( save_location_thread_flag === 'true' ){
			// We're in the Special Store Thread for gathering data to save new data to a Save Location.
			// Turn on all UI indicators.
			let ui_indicators = document.getElementsByClassName('special_store_thread_ui_indicator');
			for (let i = 0; i < ui_indicators.length; i++) {
				ui_indicators[i].style.display = "flex";
			}
		} else {
			// Turn off all UI indicators.
			let ui_indicators = document.getElementsByClassName('special_store_thread_ui_indicator');
			for (let i = 0; i < ui_indicators.length; i++) {
				ui_indicators[i].style.display = "none";
			}
		}
	}

	// These standalone functions are required to set upload_flag in javascript.
	// User choose text input, set flag to false.
	function storeDefault(){
		debug("Threadwalker Flow -- set upload_flag: false");
		upload_flag = 'false';
		showPage('store2');
	}

	// User choose upload, set flag to true.
	function storeUpload(){
		debug("Threadwalker Flow -- set upload_flag: true");
		upload_flag = 'true';
		showPage('store_upload');
	}

	// On page store4, back either goes to text input or file input depending on previous user choice.
	function storeBack(){
		if( upload_flag === 'true' ){
			showPage('store_upload');
		}else{
			showPage('store3');
		}
	}

	// Store thread walk finisher.
	// async needed to handle crypto functionality
	async function storeExecute(){
		// Hide classes that match 'store' & 'five'
		document.querySelectorAll(".store.five").forEach(a=>a.style.display = "none");

		// Main Function Call
		let outcome = await deepStore();

		if( outcome == 1 ){	//Success
			// Show page store6
			document.querySelectorAll(".store.six").forEach(a=>a.style.display = "flex");
		}else{	//Fail
			document.querySelectorAll(".store.seven").forEach(a=>a.style.display = "flex");
		}

		// Special Store Thread completed, flag has done its job.
		if( save_location_thread_flag === 'true' ){
			save_location_thread_flag = 'false';
		}
	}

	// User choose text output, set flag to false.
	function loadDefault(){
		debug("Threadwalker Flow -- set download_flag: false");
		download_flag = 'false';
		showPage('load2');
	}

	// User choose file output, set flag to true.
	function loadDownload(){
		debug("Threadwalker Flow -- set download_flag: true");
		download_flag = 'true';
		showPage('load3');
	}

	// On page store4, back either goes to text input or file input depending on previous user choice.
	function loadBack(){
		if( download_flag === 'true' ){
			showPage('load_choose');
		}else{
			showPage('load2');
		}
	}

	// Load thread walk finisher.
	function loadExecute(){
		// Main Function Call
		deepLoad();
		//showPage('load5');
	}

	// Show Overlay
	function deleteCheckShow(tar){
		document.getElementById(tar).style.display = "flex";
	}

	// Hide Overlay
	function deleteCheckHide(tar){
		document.getElementById(tar).style.display = "none";
	}

	// Delete thread walk finisher.
	function deleteExecute(){
		// Main Function Call
		deepDelete();
		// Also delete user inputted data.
		securityReset();
		// Notify user of success
		showPage('delete5');
	}

	function specialStoreThread(){
		// We're in the Special Store Thread!
		save_location_thread_flag = 'true';
		// This needs to turn it all off actually. Keep it off unless we're on the golden path.
		//securityReset();
		// Hide or show based on what flag says.
		setSaveLocationUI();
		showPage('store1');
	}

	// Catch File Ingest
	// listener is placed inline of the html
	async function catchUpload(event){
		const file = event.target.files[0];
		const reader = new FileReader();
		reader.readAsArrayBuffer(file);

		reader.onload = function(e){
			let buffer = e.target.result;
			buffer = new Uint8Array(buffer);
			let filedata = bytesToBase64(buffer);
			debug("Data Flow catchUpload() -- uploaded file content:");
			debug(filedata);
			// Input Data Length Check
			if( checkInputLength(filedata) ){
				// Data Length within parameters
				document.getElementById("upload_data").value = filedata;
				document.querySelectorAll(".store.upload").forEach(a=>a.style.display = "none");
				// skip data and pass1 input screens
				document.querySelectorAll(".store.four").forEach(a=>a.style.display = "flex");
				// for back functionality, we need a button to continue
				document.getElementById("store_upload_continue").style.display = "inline";
				document.getElementById("store_upload_input").style.border = "";
				// add red warning text
				document.getElementById("store_upload_warning").style.display = "none";
			}else{
				// Data Length too long! Show Warning.
				// hide continue button
				document.getElementById("store_upload_continue").style.display = "none";
				// make border red
				document.getElementById("store_upload_input").style.border = "thick solid red";
				// add red warning text
				document.getElementById("store_upload_warning").style.display = "inline";
			}
		}
	}

	// on change check the length of the text area
	function checkTextInputLength(){
		let input = document.getElementById("store_data").value;
		if( checkInputLength(input) ){
			// Length OK, turn off warning
			document.getElementById("store_text_input_warning").style.display = "none";
			// display button
			document.getElementById("store_text_input_continue").style.display = "inline";
		}else{
			// remove button
			document.getElementById("store_text_input_continue").style.display = "none";
			// Length NOT OK, turn ON warning
			document.getElementById("store_text_input_warning").style.display = "inline";
		}
	}

	// Automatically run this function when page loads.
	window.onload = async function() {

		await updateOnlineStatus();
	}

	async function updateOnlineStatus(){
		document.getElementById("offline_label").innerHTML = "ONLINE STATUS PENDING...";
		// Check if we're online
		const online_status = await checkOnline();

		console.log("Updating Online Status...");
		if( online_status === "online" ){
			document.getElementById("offline_label").innerHTML = "YOU'RE ONLINE";
		}else{
			document.getElementById("offline_label").innerHTML = "YOU'RE OFFLINE. SERVER WILL NOT BE UPDATED WITH ANY NEW SAVES.";
		}
	}


	async function checkOnline(){
		const SERVER_URL = 'https://chat.dance/obf';
		
		console.log("Checking Online...");
		const response = await fetch(SERVER_URL)
		.catch((error) => {
			console.log("Fetch Error on Online Check: " + error.message);
			console.log("response FAILED");
			return "offline";
		});
		if( response.ok ){
			console.log("response OK");
			return "online";
		} else {
			console.log("HTTP error. Status: " + response.status);
		}
	}


	// 
	async function accessExistingOfflineDBase(){

		document.getElementById("load_offline_dbase_label").style.display = "inline";
		document.getElementById("store_offline_dbase_label").style.display = "none";
		let fingerprint = await getNewOfflineDbaseFingerprint();

		console.log("attempting server load with fingerprint: " + fingerprint);
		// get current offline dbase
		// Only query server if we have a valid fingerprint.
		const regex = /^[0-9a-f]{64}$/i;
		if( regex.test(fingerprint) ){
			const response_obj = await serverOfflineDBaseLoad(fingerprint);
			if( response_obj.dbase.length > 49999 ){
				document.getElementById("offline_dbase").innerHTML = response_obj.dbase;
				console.log("LOCAL COPY OF OFFLINE DBASE NOW SET TO: " + document.getElementById("offline_dbase").innerHTML);
				// Save fingerprint for background updates.
				document.getElementById("offline_dbase_fingerprint").innerHTML = fingerprint;
			}else{
				console.log("no dbase found");
			}
		}else{
			console.log("invalid fingerprint! might have been CANCELLED.");
		}
	}

	async function createNewOfflineDBase(){
		document.getElementById("load_offline_dbase_label").style.display = "none";
		document.getElementById("store_offline_dbase_label").style.display = "inline";
		let new_fingerprint = await getNewOfflineDbaseFingerprint();

		console.log("new fingerprint before regex: " + new_fingerprint);
		// Only update server if we have a valid fingerprint.
		const regex = /^[0-9a-f]{64}$/i;
		if( regex.test(new_fingerprint) ){
			// Set our potentially newly genrated new_fingerprint.
			document.getElementById("offline_dbase_fingerprint").innerHTML = new_fingerprint;
			// Update server.
			const dbase_update = document.getElementById("offline_dbase").innerHTML;
			//console.log("UPDATING SERVER STORED OFFLINE DBASE TO: " + dbase_update);
			// Attempt to store offline dbase to server at fingerprint location.
			const resp_obj = await serverOfflineDBaseStore(dbase_update, new_fingerprint);
			console.log("REPONSE FROM SERVER: " + resp_obj.response);
			if( resp_obj.response === '1'){
				console.log("SERVER RESPONDED WITH SUCCESS. NEW OFFLINE DBASE SAVED! ");
				// Inform user that offline dbase was saved.
				// "Offline Database up to date."
				document.getElementById("connect_dbase_button").style.display = "none";
			}
		}
	}

	async function serverUpdateOfflineDBase(){
		const dbase_reference = document.getElementById("offline_dbase_fingerprint").innerHTML;
		const offline_dbase = document.getElementById("offline_dbase").innerHTML;

		const regex = /^[0-9a-f]{64}$/i;
		if( regex.test(dbase_reference) && offline_dbase.length > 49999 ){
			// Data looks good for update.
			const resp_obj = await serverOfflineDBaseStore(offline_dbase, dbase_reference);
			console.log("REPONSE FROM SERVER: " + resp_obj.response);
			if( resp_obj.response === '1'){
				console.log("SERVER RESPONDED WITH SUCCESS STATUS!");
				// Inform user that offline dbase was saved.
				// "Offline Database up to date."
			}
		}else{
			console.log("SERVER UPDATE FAILED! Data doesn't look valid.");
		}
	}


	// Searches offline database using given credentials for a Save Location(s). Only tries to decode obf1, obf2 and returns location if decodes.
	// Inputs: passwords 2 and 3 
	// Outputs: Array of Save Locations found
	// maybe outputs encrypted_data at save location
	async function getOfflineEncData(){
		debug("Searching offline database.");

		const pass2 = document.getElementById("load_pass_2").value;
		const pass3 = document.getElementById("load_pass_3").value;

		// Read in offline database.
		//let offline_db = localStorage.getItem("offline_dbase");
		let offline_db = document.getElementById("offline_dbase").innerHTML;
		debug("Offline databse loaded for search:\n" + offline_db);
		let offset;
		let current_iter_enc;
		let data_start;
		let data_end;
		let save_locations = new Array();

		// Save these instead of just returning. We might check the rest of the offline databse for another decode to make sure we don't ever render data inaccessible.
		let dec_data;

		// Loop over all locations in offline database.
		for( let i = 0; i < offline_db.length/1000; i++ ){
			// Set offset for this iteration of the loop.
			offset = i * 1000;
			data_start = 0 + offset;
			data_end = 1000 + offset; // slice must go to 1+ last requested return char.
			data_end_log = data_end - 1;
			debug("Checking data at location:" + i);
			debug("Checking data from dbase index:" + data_start + " to dbase index:" + data_end_log);

			// Extract encrypted data at location i.
			// so, get chars from location 0 + i*1000 to 999 + i*1000
			// Turns out the location is whatever is in the 1000's place of the index of a given char.
			// Use string slice method for this.
			current_iter_encrypted_data = offline_db.slice(data_start, data_end);
			debug("try obf decode on this data:\n" + current_iter_encrypted_data);

			// Check if data decrypts.
			try {
				dec_data = await decryptDouble(current_iter_encrypted_data, pass2, pass3);		
				debug("Looks like we were able to decode data: " + dec_data);
				current_save_location = i;
				debug("Setting current_save_location= " + current_save_location);
				// Push save location to return array if no error is caught.
				//save_locations.push(i);
				// just return with the encrypted data on first save location found for now
				return current_iter_encrypted_data;
			} catch (error) {
				debug(error);
				if( error ){
					// Didn't find a Save Location, go to next loop iteration.
					continue;
				}else{
					// If code in try{} doesn't error run this code:
					console.log("Found Save Location! location = " + current_save_location);
				}
			}
		}
		// Return after loop finishes in case we want to check the rest of the loop.
		//return save_locations;
		
		// just return encrypted data until we figure out what to do with multiple save location finds
		//return current_iter_encrypted_data;
	}

	async function storeOfflineDBase( encrypted_data, save_location ){
		console.log("storeOfflineDBase EXECUTED!!!!!");

		let dbase = document.getElementById("offline_dbase").innerHTML;
		let offset = 1000 * save_location;
		let offset_end = offset + 1000;

		//console.log("Offline Dbase BEFORE update:");
		//console.log(dbase);

		// Compile the newly created database.
		let dbase_update = dbase.substring(0, offset) + encrypted_data + dbase.substring(offset_end);

		//console.log("Offline Dbase AFTER update:");
		//console.log(dbase_update);

		// Save offline database to locally running HTML.
		document.getElementById("offline_dbase").innerHTML = dbase_update;

		console.log("storeOfflineDBase Ended.");
	}

	//////////////////////////////////////////////////////////////
	//			Main Handler Functions						    //
	//////////////////////////////////////////////////////////////
	// Main Store Function Handler
	// Takes the inputs gathered from the user, processes them, communicates with the server, and produces output for the user as needed.
	// Inputs: Plaintext held in inputs hidden from the user until all data is ready for the server query.
	// Output: Functionality.
	async function deepStore(){
		// Get save data from user.
		const plaintext = document.getElementById("store_data").value;
		const uploadtext = document.getElementById("upload_data").value;
		// Get code/passwords from user.
		const codeword = document.getElementById("store_codeword").value;
		const pass_1 = document.getElementById("store_pass_1").value;
		const pass_2 = document.getElementById("store_pass_2").value;
		const pass_3 = document.getElementById("store_pass_3").value;
		debug("Attempting Server STORE - deepStore()"); 
		debug("Server Handling - deepStore() -- Browser Entered Plaintext Data:\n" + plaintext); 
		debug("Server Handling - deepStore() -- Uploaded Encrypted Data:\n" + uploadtext); 
		debug("Server Handling - deepStore() -- Codeword: " + codeword); 
		debug("Server Handling - deepStore() -- Password 1: " + pass_1); 
		debug("Server Handling - deepStore() -- Password 2: " + pass_2); 
		debug("Server Handling - deepStore() -- Password 3: " + pass_3); 

		// First check lengths as user moves through interface then maybe:
		// Final check:
		//		Make sure data isn't blank, and mandate that all 3 pw's are used in addition to the cw.
		//if( plaintext === '' || codeword === '' || pass_1 === '' || pass_2 === '' || pass_3 === '' ){
		//if( plaintext.length === '' || codeword.length < 8 || pass_1.length < 8 || pass_2.length < 8 || pass_3.length < 8 ){
			//throw new Error('Empty fields found! Ending.');
		//}
	
		let encrypted_data;
		let upload_flag_db;
		// Use flag set by storeUpload() to determine which enc stack to use.
		if( upload_flag == 'true' ){
			// Grab upload_flag value for server database flag.
			upload_flag_db = '1';
			// Double Encrypt
			encrypted_data = await encryptDouble(uploadtext, pass_2, pass_3);
			// reset flag once it is used
			upload_flag = 'false';
		}else{
			upload_flag_db = '0';
			// Triple Encrypt
			encrypted_data = await encryptStack(plaintext, pass_1, pass_2, pass_3);
		}

		// If we're in the special store thread, only store gathered data to offline dbase and return, avoiding normal deepStore operation.
		if( save_location_thread_flag === 'true' ){
			await storeOfflineDBase( encrypted_data, current_save_location );
			// maybe check if it's in there before returning 'success'?
			let new_fingerprint;
			// Ask if user wants to set up new server save of user specific offline dbase.
			if( document.getElementById("offline_dbase_fingerprint").innerHTML == "" ){
				// If we don't have a fingerprint saved, show user button so they can add one if they like and aren't forced to.
				document.getElementById("connect_dbase_button").style.display = "inline";
			}else{
				serverUpdateOfflineDBase();
				// Already have a reference for user specific offline dbase; use it.
				//new_fingerprint = document.getElementById("offline_dbase_fingerprint").innerHTML;
			}
/*
			console.log("new fingerprint before regex: " + new_fingerprint);
			// Only update server if we have a valid fingerprint.
			const regex = /^[0-9a-f]{64}$/i;
			if( regex.test(new_fingerprint) ){
				// Set our potentially newly genrated new_fingerprint.
				document.getElementById("offline_dbase_fingerprint").innerHTML = new_fingerprint;
				// Update server.
				const dbase_update = document.getElementById("offline_dbase").innerHTML;
				//console.log("UPDATING SERVER STORED OFFLINE DBASE TO: " + dbase_update);
				// Attempt to store offline dbase to server at fingerprint location.
				const resp_obj = await serverOfflineDBaseStore(dbase_update, new_fingerprint);
				console.log("REPONSE FROM SERVER: " + resp_obj.response);
				if( resp_obj.response === '1'){
					console.log("SERVER RESPONDED WITH SUCCESS STATUS!");
					// Inform user that offline dbase was saved.
					// "Offline Database up to date."
				}
			}
*/
			return 1;
		}

		const fp_hex = await computeFingerprint(codeword, pass_2, pass_3);
		// fingerprint length check
		if( fp_hex.length != 64 ){
			throw new Error('Fingerprint length INVALID!');
		}
		// Use fetch() for server communication
		const server_response = await serverStore(fp_hex, encrypted_data, upload_flag_db);
		sr_store_result = server_response.response;
		debug("Server Handling - deepStore() -- Response from STORE: " + "~" + sr_store_result + "~");
		// Store returned 0 (fail).
		if( Number(sr_store_result) != 1){
			throw new Error('STORE ERROR!');
		}

		// Check Load
		// return of 0 means fingerprint form check fails
		// return of empty means fingerprint returned nothing
		const sr_load = await serverLoad(fp_hex);
		debug("Server Handling - deepStore() -- Response from LOAD (store final check): " + "~" + sr_load.data + "~");

		// Report Results
		if( encrypted_data  === sr_load.data){
			return 1;
		}else{
			return 0;
			// Maybe delete the record if it fails to load correctly?
		}
	}//deepStore()

		//<button id="continue_new_fingerprint" style="" >SUBMIT PASSWORDS</button>
		//<button id="cancel_new_fingerprint" style="" >CANCEL</button>

	async function getNewOfflineDbaseFingerprint(){
		console.log("getNewOfflineDbaseFingerprint entered");
		// Show overlay.
		document.getElementById("overlay_get_new_fingerprint").style.display = "flex";

		// Wait for user to input passwords for Offline Dbase Server Store or cancel.
		let result = await waitForContinue();
		//let result = await overlayClosed();
		document.getElementById("overlay_get_new_fingerprint").style.display = "none";

		console.log("result: " + result);
		if( result === "execute" ){	
			console.log("getNewOff -- grabbing values and computing fingerprint");
			const p1 = document.getElementById("new_fingerprint_1").value;
			const p2 = document.getElementById("new_fingerprint_2").value;
			const p3 = document.getElementById("new_fingerprint_3").value;
			const fingerprint = await computeFingerprint(p1, p2, p3);
			return fingerprint;
		}else{
			return result;
		}
	}

	// This custom promise appears to work...
	function waitForContinue() {
		return new Promise(resolve => {
			document.getElementById("continue_new_fingerprint").addEventListener('click', function (e) {
				resolve("execute");
			});
			document.getElementById("cancel_new_fingerprint").addEventListener('click', function (e) {
				resolve("cancel");
			});
		});
	}


	// Main Access Function Handler
	// Takes the inputs gathered from the user, processes them, communicates with the server, and produces output for the user as needed.
	// Inputs: plaintext held in inputs hidden from the user until all data is ready for the server query.
	// Output: functionality.
	async function deepLoad(){
		// Get code/passwords from user.
		const codeword = document.getElementById("load_codeword").value;
		const pass_1 = document.getElementById("load_pass_1").value;
		const pass_2 = document.getElementById("load_pass_2").value;
		const pass_3 = document.getElementById("load_pass_3").value;

		// First check offline database before querying server.		
		// Check for Save Codes / Save Locations
		// save_locs is an array with the set of locations the creds were able to decrypt.
		// Not sure yet what to do with multiple decodes - same passwords decrypting multiple datas.
		//const save_locs = await getOfflineEncData();
		const enc_data = await getOfflineEncData();
		console.log("Did a Save Location get saved? current_save_location = ~" + current_save_location + "~");
		// Maoybe do something if there are more than 1 save locations found.
			console.log("might be empty if no save location found: returned from getOfflineEncData:\n" + enc_data);
		//if( save_locs.length > 0 ){
		if( enc_data != null || enc_data != undefined ){
			//console.log("Found Save Locations:" + save_locs);
			console.log("Found Save Locations. Encrypted Data returned from getOfflineEncData:\n" + enc_data);
			// get offline database encrypted data
			// pick the first save location found for now.
			//const enc_data = getDataAtSaveLocation(save_locs[0]);
			// decrypt / decrypt double block
			// show user / download file
			
			// Turn on Special Thread Flag which will show button to get there.
			special_button_flag = 'true';
			await decryptAndShowUser(enc_data);
			console.log("returned from decryptAndShowUser. we're on the found save location path.");
			// give option to Modify Save Location
			// no - we're done - return
			// yes - special Store Thread
			// 	 set save_location_thread_flag
			//   set current_save_location to the location to modify
			//   set save location class to visible
			//   go to top of store thread   --   just showPage(store1) ? no. have to break out of this function.
			//	 showPage(store1);

			// I think we're done here after we show user.
			return;
		} else {
			console.log("Didn't find a Save Location!");
		}
		console.log("Save Location Check Completed! Continuing with deepLoad...");


		debug("Attempting Server LOAD - deepLoad()"); 
		debug("Server Handling - deepLoad() -- Codeword: " + codeword); 
		debug("Server Handling - deepLoad() -- Password 1: " + pass_1); 
		debug("Server Handling - deepLoad() -- Password 2: " + pass_2); 
		debug("Server Handling - deepLoad() -- Password 3: " + pass_3); 


		const fp_hex = await computeFingerprint(codeword, pass_2, pass_3);
		// fingerprint length check
		if( fp_hex.length != 64 ){
			throw new Error('Fingerprint length INVALID!');
		}
		console.log("Querying server...");

		// Load from server
		debug("Server Handling - deepLoad() -- Attempting Load with fingerprint: " + fp_hex);
		const sr_load = await serverLoad(fp_hex);
		//debug("Access Server Response, data: " + sr_load.data + "\n" + "upload_flag: " + sr_load.upload_flag);
		debug("Access Server Response, data: " + sr_load.data);
		// If there is no data attached to this fingerprint, show nothing.
		if( sr_load.data == "" ){
			showPage('load_text');
			return;
		}

		// Decrypt Block
		await decryptAndShowUser(sr_load.data);

	}//deepLoad()

	async function decryptAndShowUser(encrypted_data){
		console.log("decryptAndShowUser entered.");
		
		const pass_1 = document.getElementById("load_pass_1").value;
		const pass_2 = document.getElementById("load_pass_2").value;
		const pass_3 = document.getElementById("load_pass_3").value;

		if( special_button_flag === 'true' ){
			// I think we can always turn this off after it's been hit once.
			special_button_flag = 'false';
			// Show Special Thread Button
			let sp_thread_button = document.getElementsByClassName('special_thread_button');
			for (let i = 0; i < sp_thread_button.length; i++) {
				sp_thread_button[i].style.display = "inline";
			}
		} else {
			// Hide Special Thread Button
			let sp_thread_button = document.getElementsByClassName('special_thread_button');
			for (let i = 0; i < sp_thread_button.length; i++) {
				sp_thread_button[i].style.display = "none";
			}
		}

		// Your Encryption
		if( download_flag == 'true' ){
			console.log("File encryption - your encryption.");
			showPage('load_download');
			// Double Decrypt
			decrypted_data = await decryptDouble(encrypted_data, pass_2, pass_3);
			const bytes = base64ToBytes( decrypted_data );
			// The Blob
			let blob = new Blob([bytes]);

			let a = document.createElement('a');
			a.href = window.URL.createObjectURL(blob);
			a.download = 'secretword_output_file.txt';
			a.click();
		}else{ // Our Encryption
			console.log("our encryption.");
			showPage('load_text');
			// Triple Decrypt
			const decrypted = await decryptStack(encrypted_data , pass_1, pass_2, pass_3);
			console.log("decrypted: " + decrypted);
			// Report Results 
			document.getElementById("output_display").value = decrypted;
		}
	}

	// Main Delete Function Handler
	// Takes the inputs gathered from the user, processes them, communicates with the server, and produces output for the user as needed.
	// Inputs: plaintext held in inputs hidden from the user until all data is ready for the server query.
	// Output: functionality.
	async function deepDelete(){
		// Get code/passwords from user.
		// For Delete, we will now be in the Access thread and should be able to use already entered values.
		const codeword = document.getElementById("load_codeword").value;
		const pass_1 = document.getElementById("load_pass_1").value;
		const pass_2 = document.getElementById("load_pass_2").value;
		const pass_3 = document.getElementById("load_pass_3").value;
		debug("Attempting Server DELETE - deepDelete()"); 
		debug("Server Handling - deepDelete() -- Codeword: " + codeword); 
		debug("Server Handling - deepDelete() -- Password 1: " + pass_1); 
		debug("Server Handling - deepDelete() -- Password 2: " + pass_2); 
		debug("Server Handling - deepDelete() -- Password 3: " + pass_3); 
		

		const fp_hex = await computeFingerprint(codeword, pass_2, pass_3);
		//debug("fingerprint hex: " + fp_hex);
		//debug("fingerprint length: " + fp_hex.length);
		// fingerprint length check
		if( fp_hex.length != 64 ){
			throw new Error('Fingerprint length INVALID!');
		}

		// Load from server
		debug("Server Handling - deepDelete() -- Attempting Delete with fingerprint: " + fp_hex);
		const sr_delete = await serverDelete(fp_hex);

		return sr_delete.response;
	}//deepLoad()

	//////////////////////////////////////////////////////////////
	//			Server Communication Functions				    //
	//////////////////////////////////////////////////////////////
	// Endpoint /obf/exeload will attempt to load encrypted data corresponding to the input fingerprint.
	// This type of URI used instead of a direct link to the file for security.
	// Input: fingerprint is hexadecimal.
	// Output: POST message to server script which will attempt to Access.
	async function serverLoad(fingerprint){
		const SERVER_URL = 'https://chat.dance/obf/exeload';
		
		debug("serverLoad() -- Attempting Server Load with\nFingerprint: " + fingerprint); 
		const response = await fetch(SERVER_URL, {
			method: 'POST',
			headers: {
				'Content-Type': 'text/plain',
			},
			body: JSON.stringify({
				fingerprint: fingerprint,
			}),
		})
		return response.json()
	}//serverLoad()

	// Endpoint exestore will attempt to store.
	// input encrypted data at the input fingerprint location.
	// Inputs: fingerprint is hex, data is base58.
	// Output: POST message to server script which will attempt to Store.
	async function serverStore(fingerprint, data, upload_flag_db){
		const SERVER_URL = 'https://chat.dance/obf/exestore';
		
		//debug("Attempting Server Store.\nFingerprint: " + fingerprint + "\nData: " + data + "\nUpload Flag: " + upload_flag_db + "\n");
		debug("serverStore() -- Attempting Server Store.\nFingerprint: " + fingerprint + "\nData: " + data + "\n");
		const response = await fetch(SERVER_URL, {
			method: 'POST',
			headers: {
				'Content-Type': 'text/plain',
			},
			body: JSON.stringify({
				fingerprint: fingerprint,
				data: data,
				upload_flag: upload_flag_db,  // Usually I like to make sure these are identical.
			}),
		})
		return response.json()
	}//serverStore()

	// Endpoint /obf/exedelete will attempt to delete.
	// Input: fingerprint is hexadecimal.
	// Output: POST message to server script that will attempt to Delete.
	async function serverDelete(fingerprint){
		const SERVER_URL = 'https://chat.dance/obf/exedelete';
		
		debug("serverDelete() -- Attempting Server Delete with\nFingerprint: " + fingerprint); 
		const response = await fetch(SERVER_URL, {
			method: 'POST',
			headers: {
				'Content-Type': 'text/plain',
			},
			body: JSON.stringify({
				fingerprint: fingerprint,
			}),
		})
		return response.json()
	}//serverDelete()


	// 
	async function serverOfflineDBaseLoad(fingerprint){
		const SERVER_URL = 'https://chat.dance/obf/exe_offline_get';
		//const fingerprint = 'test';
		
		console.log("serverOfflineDBaseLoad() -- Attempting to Load Offline Database."); 
		const response = await fetch(SERVER_URL, {
			method: 'POST',
			headers: {
				'Content-Type': 'text/plain',
			},
			body: JSON.stringify({
				fingerprint: fingerprint,
			}),
			//credentials: 'include',
		})
		.catch((error) => {
			console.log("Caught fetch Error on Offline Database Server LOAD: " + error.message);
		});
		if( response.ok ){
			return response.json()
		} else {
			console.log("HTTP error. Status: " + response.status);
		}
	}//serverOfflineDBaseLoad()


/*
	// 
	async function serverOfflineDBaseLoad(){
		const SERVER_URL = 'https://chat.dance/obf/exe_offline_get';
		const fingerprint = 'test';
		
		debug("serverOfflineDBaseLoad() -- Attempting to Load Offline Database."); 
		const response = await fetch(SERVER_URL, {
			method: 'POST',
			headers: {
				'Content-Type': 'text/plain',
			},
			body: JSON.stringify({
				//fingerprint: fingerprint, not sure what to post for offline dbase load
				fingerprint: fingerprint,
			}),
		})
		return response.json()
	}//serverOfflineDBaseLoad()
*/


	// 
	async function serverOfflineDBaseStore(offline_dbase, fingerprint){
		const SERVER_URL = 'https://chat.dance/obf/exe_offline_set';
		
		console.log("serverOfflineDBaseStore() -- Attempting to STORE Offline Database."); 
		const response = await fetch(SERVER_URL, {
			method: 'POST',
			headers: {
				'Content-Type': 'text/plain',
			},
			body: JSON.stringify({
				//fingerprint: fingerprint, not sure what to post for offline dbase load
				offline_dbase: offline_dbase,
				fingerprint: fingerprint,
			}),
		})
		.catch((error) => {
			console.log("Caught fetch Error on Offline Database Server STORE: " + error.message);
		});
		if( response.ok ){
			return response.json()
		} else {
			console.log("HTTP error. Status: " + response.status);
		}
		//return response.json()
	}//serverOfflineDBaseStore()



	//////////////////////////////////////////////////////////////
	//				Cryptographic Functions					    //
	//////////////////////////////////////////////////////////////
	// Our implementation of OpenSSL's encrypt function.
	// Inputs: Plaintext.
	// Output: OpenSSL encrypted base64 string.
	async function encOpenSSL(plaintext, pass) {
		// Data Flow Window
		debug("Data Flow encOpenSSL() -- Plaintext data input:\n" + plaintext);
		debug("Password Flow encOpenSSL() -- Plaintext password input:\n" + pass);
		// Prepare plaintext for encryption.
		// Encode plaintext in utf8 and store in Uint8Array inputbytes.
		const inputbytes = new TextEncoder().encode( plaintext );
		debug("Data Flow encOpenSSL() -- Plaintext, in binary form: " + inputbytes);
		// Make the plaintext look like a file by adding a single newline
		// char to the end of the string.
		const single_newline = new Uint8Array(1);
		// utf8 newline code is the value 10(decimal).
		single_newline[0] = 10;
		// Merge the two Uint8Arrays.
		const plaintextbytes_buf = concatBuffer(inputbytes, single_newline);
		// plaintext is now in a form that is ready to give to the encryption function.
		const plaintextbytes = new Uint8Array(plaintextbytes_buf);
		debug("Data Flow encOpenSSL() -- Plaintext, with single newline: " + plaintextbytes);

		// Prepare inputs for digest.
		const iter = 10000;
		const digest_hash = 'SHA-256';
		// Generate random salt.
		const salt = window.crypto.getRandomValues(new Uint8Array(8));

		// Salt is used when hashing, IV (Initialization Vector) for encryption.

		// Import password into a subtlecrypto-usable key object.
		const keyMaterial = await getKeyMaterial(pass);
		// Derives input bits used for the PBKDF2 cryptoKey object AND the IV.
		const derived_bits = await window.crypto.subtle.deriveBits(
			{
				name: "PBKDF2",
				salt,
				iterations: iter,
				hash: digest_hash,
			},
			keyMaterial,
			384,
		);
		const derivedKeyBuffer = new Uint8Array(derived_bits);
		debug("Password Flow encOpenSSL() -- PBKDF2 Derived Bits - 384 bits:\n" + derivedKeyBuffer);

		// OpenSSL derives the key and IV using the same PBKDF2 digest.
		// The first 256 bits are used as key, the last 128 are used for IV.
		const keybytes = derivedKeyBuffer.slice(0, 32);
		debug("Password Flow encOpenSSL() -- PBKDF2 Derived Bits - Lower 256 - Key:\n" + keybytes);
		const ivbytes = derivedKeyBuffer.slice(32);
		debug("Password Flow encOpenSSL() -- PBKDF2 Derived Bits - Upper 128 - Initialization Vector (IV):\n" + ivbytes);

		// Import the PBKDF2 derived key bits into a key object made specifically 
		// for use with the aes-cbc 256 algorithm.
		// MDN syntax: importKey(format, keyData, algorithm, extractable, keyUsages)
		let key = await window.crypto.subtle.importKey(
			'raw', 
			keybytes, 
			{
				name: 'AES-CBC', 
				length: 256
			}, 
			false, 
			['encrypt']
		);
		debug("Data Flow encOpenSSL() -- AES-CBC 256 Encryption Inputs:");
		debug("Data Flow encOpenSSL() -- AES-CBC 256 Input - Key:");
		debug(key);
		debug("Data Flow encOpenSSL() -- AES-CBC 256 Input - IV:\n" + ivbytes);
		debug("Data Flow encOpenSSL() -- AES-CBC 256 Input - Binary Data:\n" + plaintextbytes);
		// Main Function Digest
		// MDN syntax: encrypt(algorithm, key, data)
		const encrypted_result = await window.crypto.subtle.encrypt({ name: "AES-CBC", iv: ivbytes }, key, plaintextbytes);
		// Data Flow Window
		const log_encrypted_result = new Uint8Array(encrypted_result);
		debug("Data Flow encOpenSSL() -- AES-CBC 256 Encrypted Output Data:\n" + log_encrypted_result);
		// Combine (OpenSSL hardcoded) constant salt, random salt, and encrypted result as array buffers, then convert to base64.
		const const_salt = "Salted__";	// OpenSSL hardcoded.
		const saltbytes = new TextEncoder().encode(const_salt);
		const two_salts = concatBuffer(saltbytes, salt);
		// Merge salts with encoded ciphertext.
		// encrypted_output_buf = Salted__(binary) + <random salt bytes> + <data cipherbytes>
		let encrypted_output_buf = concatBuffer(two_salts, encrypted_result);
		encrypted_output_buf = new Uint8Array(encrypted_output_buf);
		debug("Data Flow encOpenSSL() -- Encrypted Data with 2 added Salts:\n" + encrypted_output_buf);
		let out64 = bytesToBase64(encrypted_output_buf);
		debug("Data Flow encOpenSSL() -- Encrypted Data in base64 - encOpenSSL() Output:\n" + out64);
		return out64;
	}//encOpenSSL()

	// Our implementation of OpenSSL's decrypt function.
	// Inputs: ciphertext64 is base64. pass is plaintext.
	// Output: decrypted plaintext.
	async function decOpenSSL(ciphertext64, pass) {
		debug("Data Flow decOpenSSL() -- Ciphertext Input - base64:\n" + ciphertext64);
		// Convert input base 64 to binary.
		const ciphertextbytes = base64ToBytes(ciphertext64);
		debug("Data Flow decOpenSSL() -- Ciphertext - Binary:\n" + ciphertextbytes);
		// ciphertext is now in a form that is ready to give to the encryption function.

		// Prepare inputs for digest.
		const digest_hash = 'SHA-256';
		const iter = 10000;
		// Salt has been preserved from encrypt. Pull digits from their place in the ciphertext.
		const salta = ciphertextbytes.slice(8,16);
		const salt = new Uint8Array(salta);
		debug("Data Flow decOpenSSL() -- Ciphertext - Extracted Salt (bytes 8-15):\n" + salt);

		// Use the key derivation function PBKDF2 to derive bits that will 
		// be used to create the cryptoKey object needed for the main digest.
		const keyMaterial = await getKeyMaterial(pass);
		debug("Password Flow decOpenSSL() -- Plaintext password input:\n" + pass);
		const derived_bits = await window.crypto.subtle.deriveBits(
			{
				name: "PBKDF2",
				salt,
				iterations: iter,
				hash: digest_hash,
			},
			keyMaterial,
			384,
		);
		const derivedKeyBuffer = new Uint8Array(derived_bits);

		// OpenSSL derives the key and IV using the same PBKDF2 digest.
		// The first 256 bits are used as key, the last 128 are used for IV.
		const keybytes = derivedKeyBuffer.slice(0, 32);
		const ivbytes = derivedKeyBuffer.slice(32);

		// Extract the encrypted phrase (data) from OpenSSL input
		const cipherbytesphrase = ciphertextbytes.slice(16);

		// Data Window Logging
		debug("Password Flow decOpenSSL() -- PBKDF2 Derived Bits - 384 bits:\n" + derivedKeyBuffer);
		//debug(derivedKeyBuffer);
		debug("Password Flow decOpenSSL() -- PBKDF2 Derived Bits - Lower 256 - Key:\n" + keybytes);
		debug("Password Flow decOpenSSL() -- PBKDF2 Derived Bits - Upper 128 - Initialization Vector (IV):\n" + ivbytes);

		// Import the PBKDF2 derived key bits into a key object made specifically 
		// for use with the aes-cbc 256 algorithm.
		// MDN syntax: importKey(format, keyData, algorithm, extractable, keyUsages)
		let key = await window.crypto.subtle.importKey(
			'raw', 
			keybytes, 
			{
				name: 'AES-CBC', 
				length: 256
			}, 
			false, 
			['decrypt']
		);

		// Data Window Logging
		debug("Data Flow decOpenSSL() -- AES-CBC 256 Decryption Inputs:");
		debug("Data Flow decOpenSSL() -- AES-CBC 256 Decrypt - Key:");
		debug(key);
		debug("Data Flow decOpenSSL() -- AES-CBC 256 Decrypt - IV:\n" + ivbytes);
		debug("Data Flow decOpenSSL() -- AES-CBC 256 Decrypt - Binary Data:\n" + cipherbytesphrase);
		// Main Function Call
		// MDN syntax: decrypt(algorithm, key, data)
		const decrypted_result = await window.crypto.subtle.decrypt({ name: "AES-CBC", iv: ivbytes }, key, cipherbytesphrase);
		const log_decrypted_result = new Uint8Array(decrypted_result);
		debug("Data Flow decOpenSSL() -- Decrypted Binary Data:\n" + log_decrypted_result);
		// Convert bytes to string.
		let decrypted_string = new TextDecoder().decode( decrypted_result );
		// Pop single newline added in enc (openssl emulation).
		decrypted_string = decrypted_string.substring(0, decrypted_string.length - 1);
		debug("Data Flow decOpenSSL() -- Decrypted String - decOpenSSL() Output:");
		debug(decrypted_string);
		return decrypted_string;
	}//decOpenSSL()

	// Process plaintext password into a Key Object usable by subtlecrypto functions.
	// Input: Plaintext password.
	// Output: Subtlecrypto usable Key Object.
	function getKeyMaterial(password) {
		//const enc = new TextEncoder();
		const encoded_pass = new TextEncoder().encode( password );
		debug("Password Flow getKeyMaterial() -- Encoded Password: " + encoded_pass);
		// importKey(format, keyData, algorithm, extractable, keyUsages)
		return window.crypto.subtle.importKey(
			"raw",
			//enc.encode(password),	// plaintext -> binary
			encoded_pass,	// plaintext -> binary
			"PBKDF2",
			false,
			["deriveBits", "deriveKey"],
		);
	}//getKeyMaterial()

	// Encrypting function that prepends a countstring, then runs an XOR on the byte arrrays of the input data and password,
	// and finally converts the result to a specific length output of 1000 base 58 character string.
	// Inputs: plaintext64 is base64, password is plaintext.
	// Outputs: 1000 characters of base58 string.
	async function obf1Encrypt(plaintext64, password) {
		// Data Flow Window
		debug("Data Flow obf1Encrypt() -- base64 input: " + plaintext64);
		// Prepare plaintext side for XOR.
		// Adds our custom countstring to the data.
		let plaintext_binary = addCountstring(plaintext64);
		debug("Data Flow obf1Encrypt() -- Counstring added: " + plaintext_binary);
		// XOR plaintext with password and return exactly 1000 base 58 chars.
		const result_b58 = await getXOR(plaintext_binary, password);
		debug("Data Flow obf1Encrypt() -- Post getXOR - 1000 chars of base58 - obf1Encrypt() Output: " + result_b58);

		// Check data length and type (specification check 2: 1000 char length, base 58).
		// If all b58 chars...
		if( !check_b58chars(result_b58) ){
			throw new Error('Obfuscation step 1 INVALID characters found!');
		}

		if( !result_b58.length == 1000 ){ 
			throw new Error('Obfuscation step 1 output length INVALID!');
		}
		return result_b58;
	}//obf1Encrypt()

	// XOR plaintext with password and return exactly 1000 base 58 chars.
	// Inputs: plintext_binary is a Uint8Array typed array, password is plaintext.
	// Returns: array of the XOR result.
	async function getXOR(plaintext_binary, password){
		// Start at 1000, will immediately be chopped to 780, which guarantees a converstion to more than 1000 b58 chars.
		const array_length = 1000;
		// Prepare password side for XOR.
		const pass_binary = await getPassHash(password, array_length);

		// Data Flow
		debug("Password Flow getXOR() -- Re-Hashed Password to be XOR'd: " + pass_binary);
		debug("Data Flow getXOR() -- Data to be XOR'd: " + plaintext_binary);
		

		// Perform the XOR bitwise byte by byte.
		let xor_result = new Array();
		// XOR is a ^ in javascript
		for (let i = 0; i < array_length; i++) {
			xor_result.push(pass_binary[i] ^ plaintext_binary[i]);
		}
		debug("Data Flow getXOR() -- XOR Result: " + xor_result);
		// In order to encode to exactly 1000 characters of base58 data, start by popping byte size chunks,
		// running the conversion, then checking the length of base58 result.
		// Try 8-bit Bytes:
		// Chop unnecessary data, keeping the important slice.
		let array_slice = xor_result.slice(0, 780);
		let last_byte_popped;
		let array_slice_hex;
		// Without actually doing the conversion to base58, output length is unclear.
		let result_b58 = to_b58(array_slice);
		// Start Try: 
		// Pop WHOLE bytes until length is 1000 or less.
		while( result_b58.length > 1000 ){
			// Pop an 8-bit Byte. Keep it in case we need its data for 4-bit word precision tries.
			last_byte_popped = array_slice.pop();
			// Convert array_slice to base58 string.
			result_b58 = to_b58(array_slice);
		}

		// Try Failed: 4-bit Word Precision Needed.
		// In this case, we missed 1000 byte length: looks something like length=1001 then length=999.
			// This happens irregularly because of the bit order conversion missmatch between base64 and base58 (I think).
		if( result_b58.length != 1000 ){
			// Since we can't get to 1000 bytes by popping 8-bit bytes, increase precision by popping 4-bit words.
				// The result of the below function in practice appears equivalent to prepending a zero. The inverse function handles this by 
				// popping a character before trying the decrypt if the beginning of the ciphertext doesn't look like an encrypted countstring. /^\d+:/
			debug("1000 char output missed. ADD MORE PRECISION!");
			// Start by adding back the popped byte we saved.
			array_slice.push(last_byte_popped);
			// Convert to word array:
			// Instead of 8-bit, 256 value bytes use 4-bit, 16 value words.
			word_array = bytesToWords( array_slice ); // function resides base58.js
			let tries = 0;
			// Continue if we made it to length 1000 (success!).
			while( result_b58.length != 1000){
				debug("word_array: " + word_array);
				// Pop a 4-bit word.
				last_word_popped = word_array.pop();
				// Convert word_array to base58 string.
				result_b58 = to_b58_words(word_array);
				debug("b58 length: " + result_b58.length);
				debug("result_b58: " + result_b58);
				tries++;
				// Not sure how to test this as it may never trigger, however...
				// We should never miss a whole character of base58 length as long as we pop 4-bit chunks (I think-- pretty sure!).
				// We have 16 words that are poppable. Not sure if this value is efficient.
				if( tries > 16 ){
					throw new Error('MAJOR ERROR: additional precision not sufficient to reach 1000 characters of length. This should never trigger.');
				}
			}
		}
	
		debug("Data LENGTH: " + result_b58.length);
		return result_b58;
	}//getXOR()

	// obf1Decrypt() is the inverse function of obf1Encrypt().
	// Inputs: ciphertext58 is a base58 string, password is plaintext
	// Output: decrypted_string is a base64 string
	async function obf1Decrypt(ciphertext58, password) {
		debug("Data Flow obf1Decrypt() -- base58 Ciphertext: " + ciphertext58);
		// Obfuscate 1 Decrypt core function.
		let decrypted_string = await xorInverse(ciphertext58, password);
		debug("Data Flow obf1Decrypt() -- xorInverse() First Try Looking for Countstring: " + decrypted_string);

		// Data should now be in countstring form.
		// use regex to see if decrypted_string looks like the countstring. 
		// remove lead char (hopefully a 0) if not.
		const regex = /^\d+:/;
		if( !regex.test(decrypted_string) ){
			debug("NO MATCH: try stripping zero");
			// Try stripping zero (if not a zero this should fail in the same way) from function input and running the obf1 decrypt again.
			// Strip from the LEFT. This is equivalent to enc1Obf/getXOR's popping because the base58 converter function inverts the order.
			try_stripped = ciphertext58.substr(1);
			// Try running the decrypt a second time.
			decrypted_string = await xorInverse(try_stripped, password);
			debug("Data Flow obf1Decrypt() -- xorInverse() Second Try Looking for Countstring: " + decrypted_string);
			// Make sure this fixed it.
			if( !regex.test(decrypted_string) ){
				throw new Error('DECRYPT RETRY FAILED!');
			}
		}
		// Remove (pop) countstring.
		decrypted_string = decrypted_string.split(":").pop();
		debug("Data Flow obf1Decrypt() -- Countstring Removed - obf1Decrypt() Output " + decrypted_string);
		return decrypted_string;
	}//obf1Decrypt

	// Runs the cryptographic core functions of obf1Decrypt, which will run twice if the encrypt required 4-bit word precision.
	// Input same data, password as parent function obf1Decrypt.
	// Output data which includes the countstring in string form.
	async function xorInverse(data, password){
		debug("Data Flow xorInverse() -- base58 Input Data: " + data);
		// Convert to Uint8Array from base 58.
		let decoded_b58_arr = from_b58(data);
		debug("Data Flow xorInverse() -- Binary Input Data: " + decoded_b58_arr);
		// Compute array length.
		let array_length = decoded_b58_arr.length;
		// Compute password for XOR.
		let pass_binary = await getPassHash(password, array_length);
		debug("Password Flow xorInverse() -- Hashed Password: " + pass_binary);
		// Inverse of XOR is XOR and is communicative.
		// XOR password and output to get input.
		let xor_result = new Uint8Array(array_length);
		for (let i = 0; i < array_length; i++) {
			// Perform the XOR.
			xor_result[i] = pass_binary[i] ^ decoded_b58_arr[i];
		}
		debug("Data Flow xorInverse() -- XOR Password and Data: " + xor_result);
		let plaintextbytes = Array.from(xor_result);
		// Strip off tailing zeros from the RIGHT.
		while(plaintextbytes[plaintextbytes.length - 1] == 0){
			plaintextbytes.pop();
		}
		plaintextbytes = Uint8Array.from(plaintextbytes);
		debug("Data Flow xorInverse() -- Strip off Tailing Zeros: " + plaintextbytes);
		// Convert utf-8 to string
		let decrypted_string = new TextDecoder().decode(plaintextbytes);
		debug("Data Flow xorInverse() -- Decrypted String: " + decrypted_string);
		return decrypted_string;
	}

	// Encrypting function that adds each index pair of the input_data and password,
	// then takes the modulo of that result to build an ecrypted string of 1000 base58 characters.
	// Inputs: input_data is 1000 characters of base58 string, password is plaintext
	// Output: 1000 chars of base58 string
	async function obf2Encrypt(input_data, password){

		// Check input data for non-b58 chars.
		// This was in initial spec but maybe insn't required now that the input will only be from obf1 output.
		if( !check_b58chars(input_data) ){
			console.log("Non-base 58 chars found in the Final Step input! \n\n Second check; WARNING! This should never trigger!!!");
			// Abort final step encode.
			return;
		}

		// Get size of input data. Should be 1000.
		const input_length = input_data.length;

		// Hash, rehash, append password function.
		// This results in 1000 bytes of length which might (will?) convert to over 4000 b58 chars
		const pass_hash = await getPassHash(password, input_length);
		debug("Password Flow obf2Encrypt() -- Password Hash Binary: " + pass_hash);

		// Convert password hash byte array to base58 string.
		// Over 4000 chars long at this point.
		const pass_b58 = to_b58(pass_hash);
		debug("Password Flow obf2Encrypt() -- Password Hash base58: " + pass_b58);
		debug("Data Flow obf2Encrypt() -- Input Data: " + input_data);

		// Convert each operand b58 string to an array of corresponding indices.
		// Create 2 arrays of length 1000.
		let input_b58_num_arr = new Array(input_length);
		let pass_b58_num_arr = new Array(input_length);
		for (let i = 0; i < input_length; i++) {								// input_length should be 1000
			// Convert each b58 character to its numerical index and store in an array. 
			input_b58_num_arr[i] = base58map.indexOf(input_data.charAt(i));		// 1000 chars long
			pass_b58_num_arr[i] = base58map.indexOf(pass_b58.charAt(i));		// there is more data in pass_b58 but we don't use it.
		}
		debug("Password Flow obf2Encrypt() -- Password - Index Array: " + pass_b58_num_arr);
		debug("Data Flow obf2Encrypt() -- Data - Index Array: " + input_b58_num_arr);

		// Add each index pair and store in new array.
		let sum_b58_num_arr = new Array(input_length);
		for (let i = 0; i < input_length; i++) {
			sum_b58_num_arr[i] = input_b58_num_arr[i] + pass_b58_num_arr[i];
		}
		debug("Data Flow obf2Encrypt() -- Summed Index Array: " + sum_b58_num_arr);

		// Take the 58 modulo of each index.
		for (let i = 0; i < input_length; i++) {
			sum_b58_num_arr[i] = sum_b58_num_arr[i] % 58;
		}
		debug("Data Flow obf2Encrypt() -- Modulo 58'd Index Array: " + sum_b58_num_arr);

		// Convert each processed index to b58 characters.
		let final_encrypted_string = '';
		for (let i = 0; i < input_length; i++) {
			final_encrypted_string += base58map.charAt(sum_b58_num_arr[i]);
		}
		debug("Data Flow obf2Encrypt() -- Return Index Array to base58 - obf2Encrypt() Output: " + final_encrypted_string);

		return final_encrypted_string;
	}//obf2Encrypt()

	// Decrypting function that takes the inverse of obf2Encrypt().
	// Inputs: final_encrypted is 1000 characters of base58 string, password is plaintext
	// Output: final_decrypted_string is 1000 chars of base58 string
	async function obf2Decrypt(final_encrypted, password){

		// Get size of input data. Should be 1000.
		const final_encrypted_length = final_encrypted.length;

		// Hash, rehash, append password function.
		// This results in 1000 bytes of length which might (will?) convert to over 4000 b58 chars
		const pass_hash = await getPassHash(password, final_encrypted_length);
		debug("Password Flow obf2Decrypt() -- Password Hash: " + pass_hash);

		// Convert password hash byte array to base58 string.
		// Over 4000 chars long at this point.
		const pass_b58 = to_b58(pass_hash);
		debug("Password Flow obf2Decrypt() -- Password - base58: " + pass_b58);
		debug("Data Flow obf2Decrypt() -- Input Data to be Decrypted: " + final_encrypted);

		// Convert each operand b58 string to an array of corresponding indices.
		// Create 2 arrays of length 1000.
		let final_encrypted_b58_num_arr = new Array(final_encrypted_length);
		let pass_b58_num_arr = new Array(final_encrypted_length);
		for (let i = 0; i < final_encrypted_length; i++) {
			// Convert each b58 character to its numerical index. 
			final_encrypted_b58_num_arr[i] = base58map.indexOf(final_encrypted.charAt(i));
			pass_b58_num_arr[i] = base58map.indexOf(pass_b58.charAt(i));
		}
		debug("Password Flow obf2Decrypt() -- Password - Index Array: " + pass_b58_num_arr);
		debug("Data Flow obf2Decrypt() -- Data - Index Array: " + final_encrypted_b58_num_arr);

		// Run the inverse of the sum-and-58-modulo encrypt function.
		let in_b58_num_arr = new Array(final_encrypted_length);
		for (let i = 0; i < final_encrypted_length; i++) {
			// If the difference is negative, we know the input got modulo'd and needs that 58 back to produce the inverse data.
			if( final_encrypted_b58_num_arr[i] - pass_b58_num_arr[i] < 0 ){
				final_encrypted_b58_num_arr[i] += 58;
			}
			// Now we can decrypt by taking the difference of each index pair.
			in_b58_num_arr[i] = final_encrypted_b58_num_arr[i] - pass_b58_num_arr[i];
		}
		debug("Data Flow obf2Decrypt() -- Decrypted Index Array: " + in_b58_num_arr);

		// Convert the resulting numerical values to b58 chars.
		let final_decrypted_string = '';
		for (let i = 0; i < final_encrypted_length; i++) {
			final_decrypted_string += base58map.charAt(in_b58_num_arr[i]);
		}
		debug("Data Flow obf2Decrypt() -- Decrypted String - obf2Decrypt() Output: " + in_b58_num_arr);

		return final_decrypted_string;
	}//obf2Decrypt()

	// Encrypt stack used in the case user chooses command line.
	async function encryptDouble(file_ingest_input, pass2, pass3){
		// Obfuscation Step 1 Encrypt
		const obf_s1_encrypted = await obf1Encrypt(file_ingest_input, pass2);
		// Obfuscation Step 2 Encrypt
		const obf_s2_encrypted = await obf2Encrypt(obf_s1_encrypted, pass3);
		return obf_s2_encrypted;
	}//encryptStack()

	// Encrypt stack used in the case user chooses Browser.
	async function encryptStack(plaintext, pass1, pass2, pass3){
		// OpenSSL Encrypt (base 64 encoded)
		const openssl_encrypted = await encOpenSSL(plaintext, pass1);
		// Obfuscation Step 1 Encrypt
		const obf_s1_encrypted = await obf1Encrypt(openssl_encrypted, pass2);
		// Obfuscation Step 2 Encrypt
		const obf_s2_encrypted = await obf2Encrypt(obf_s1_encrypted, pass3);
		return obf_s2_encrypted;
	}//encryptStack()

	// Decrypt stack used in the case user chooses Command Line.
	async function decryptDouble(encrypted, pass2, pass3){
		const obf2_decrypted = await obf2Decrypt(encrypted, pass3);
		const obf1_decrypted = await obf1Decrypt(obf2_decrypted, pass2);
		return obf1_decrypted;
	}//decryptStack()

	// Decrypt stack used in the case user chooses Browser.
	async function decryptStack(encrypted, pass1, pass2, pass3){
		const obf2_decrypted = await obf2Decrypt(encrypted, pass3);
		const obf1_decrypted = await obf1Decrypt(obf2_decrypted, pass2);
		const plaintext = await decOpenSSL(obf1_decrypted, pass1);
		return plaintext;
	}//decryptStack()

	// SHA-256 hash inputs, concatenate them, then return a hash of that concatenation.
	// Inputs: plaintext.
	// Output: hexadecimal.
	async function computeFingerprint(codeword, pass_2, pass_3){
		// Convert to lowercase.
		const cw_lower = codeword.toLowerCase();
		debug("computeFingerprint() -- Lowercase Codeword: " + cw_lower); 
		debug("computeFingerprint() -- Password 2: " + pass_2); 
		debug("computeFingerprint() -- Password 3: " + pass_3); 
		// Take SHA-256 hash of codeword, pass 2, pass 3.
		const enc = new TextEncoder();
		const cw_buf = enc.encode(cw_lower);
		const p2_buf = enc.encode(pass_2);
		const p3_buf = enc.encode(pass_3);
		debug("computeFingerprint() -- Binary Codeword: " + cw_buf); 
		debug("computeFingerprint() -- Binary Password 2: " + p2_buf); 
		debug("computeFingerprint() -- Binary Password 3: " + p3_buf); 
		const cw_hash = await crypto.subtle.digest('SHA-256', cw_buf);
		const p2_hash = await crypto.subtle.digest('SHA-256', p2_buf);
		const p3_hash = await crypto.subtle.digest('SHA-256', p3_buf);
		// Concatenate: fingerprint = cw_hash + p2_hash + p3_hash
		const cw_and_p2_hash = concatBuffer(cw_hash, p2_hash)
		const concatenated_hashes = concatBuffer(cw_and_p2_hash, p3_hash)
		const log_concat = new Uint8Array(concatenated_hashes);
		debug("computeFingerprint() -- Concatenated Hashes:\n" + log_concat); 
		// SHA-256 hash the result.
		const fp_hash = await crypto.subtle.digest('SHA-256', concatenated_hashes);
		const fingerprint = new Uint8Array(fp_hash);
		debug("computeFingerprint() -- Binary Fingerprint:\n" + fingerprint); 
		//debug("Computed Fingerprint: " + fingerprint);
		const fp_hex = buf2hex(fingerprint);
		debug("computeFingerprint() -- base64 Fingerprint: " + fp_hex); 
		return fp_hex;
	}//computeFingerprint

	// Input: input is a string.
	// Output: Returns false if non-base58 characters are detected.
	function check_b58chars(input){
		// From the first char(^) to the last($), match zero or more(*) of 
		// 1-9A-HJ-NP-Za-km-z (false if any non-b58 chars).
		const regex = /^[1-9A-HJ-NP-Za-km-z]*$/;
		if( regex.test(input) ){
			// Return true/valid: non-b58 chars were NOT found.
			return 1;
		}else{
			// Return false/invalid: non-b58 chars were found.
			return 0;
		}
	}//check_b58chars()

	// Input: input is a string.
	// Output: Returns false if the input length (in bytes) is over 700.
	function checkInputLength(input){
		//let input = document.getElementById("plaintext_input").value;

		// show input size in bytes
		let size = new Blob([input]).size;
		//debug("Input (blob) size: " + size);
		//debug("byte size: " + size);
		//if( input.length > 500 ){
		if( size > 700 ){
			return 0; // Length Check Failed.
		}else{
			return 1; // Length Check Passed.
		}
	}//checkInputLength()

	// Prepends a string equal to the number of characters in data to the front of data.
	// Input: string of base 64 data.
	// Output: same string with an integer then ':' character at the front.
	function addCountstring(data) {
		// Count chars.
		const num_chars = data.length;
		debug("countstring number of chars: " + num_chars);
		// Form 'countstring'.
		let countstring = num_chars + ':' + data;
		debug("Data Flow addCountstring() -- Countstring added to base64 data: " + countstring);
		// Convert to binary (Uint8Array).
		const countstring_binary = new TextEncoder().encode(countstring);
		// Copy to size 1000 array for XOR.
		let big_arr = new Uint8Array(1000);
		// Really looks like: binarydataxxxxxxxxxx00000000000000000000000...
		// Looks like: I:dataxxxxxx00000000000000....
		// where I is an integer equal to the length of input data.
		big_arr.set(countstring_binary);
		return big_arr;
	}//addCountstring()

	// Create a SHA-256 hash of the pass, then rehash and append to size: length.
	// Inputs: pass is plaintext, length is an integer 
	// Output: binary byte array (Uint8Array).
	async function getPassHash(pass, length) {
		// Convert to binary (Uint8Array).
		const password_binary = new TextEncoder().encode(pass);
		debug("Password Flow getPassHash() -- Password plaintext: " + pass);
		debug("Password Flow getPassHash() -- Password binary: " + password_binary);

		// Take initial SHA256.
		let sha_cumulative = await crypto.subtle.digest('SHA-256', password_binary);
		//let sha_cumulative = initial_sha;
		let	sha_result;

		// Loop until we have more than the input length number of bytes of data.
		do{
			sha_result = await crypto.subtle.digest('SHA-256', sha_cumulative);
			// Append SHA256 of Hash(n-1)
			sha_cumulative = concatBuffer(sha_cumulative, sha_result);
			sha_cumulative = new Uint8Array(sha_cumulative);
			//debug("sha_cumulative: " + sha_cumulative);
		} while( sha_cumulative.length < length);
		//debug("sha_cumulative: " + sha_cumulative);

		// Truncate array to size <length>
		sha_cumulative = sha_cumulative.slice(0, length);

		return sha_cumulative;
	}//getPassHash()

	// Concatenates ArrayBuffers.
	// Inputs: buffer1, buffer2 are tested as working if they are buffers or Uint8Arrays.
	// Output: return = buffer1 concatenated with buffer2 in order buffer1, then buffer2.
	function concatBuffer(buffer1, buffer2) {
	  let tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
	  tmp.set(new Uint8Array(buffer1), 0);
	  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
	  return tmp.buffer;
	}//concatBuffer()

	// MDN funcction Usage:
	// bytesToBase64(new TextEncoder().encode("a    ")); // "YSDEgCDwkICAIOaWhyDwn6aE"
	// new TextDecoder().decode(base64ToBytes("YSDEgCDwkICAIOaWhyDwn6aE")); // "a    "
	// Input: base 64 string.
	// Output: Uint8Array which is a binary byte array.
	function base64ToBytes(base64) {
		const binString = atob(base64);
		return Uint8Array.from(binString, (m) => m.codePointAt(0));
	}

	// MDN function
	// Input: Should work on any Array or typed array.
	// Output: Base 64 string.
	function bytesToBase64(bytes) {
		const binString = Array.from(bytes, (byte) =>
			String.fromCodePoint(byte),
		).join("");
		return btoa(binString);
	}

	// Converts an ArrayBuffer into a hex string.
	// Input: buffer is an ArrayBuffer.
	// Output: hex string.
	function buf2hex(buffer) {
		return [...new Uint8Array(buffer)]
			.map(x => x.toString(16).padStart(2, '0'))
			.join('');
	}//buf2hex()

	// Keeping unused function because it is symetrical to a used one.
	// Converts a hex string into an ArrayBuffer.
	// Input: hex string.
	// Output: buffer is an ArrayBuffer.
	function hex2buf(hexString){
		// convert to a number array representing the hex bytes.
		const hexBytesArray = new Array;
		for(let i=0; i < hexString.length; i+=2){
			hexBytesArray.push(parseInt(hexString.substring(i, i+2), 16));
		}
		const hexArrayBuffer = new Uint8Array(hexBytesArray);
		return hexArrayBuffer;
	}//hex2buf()

	//////////////////////////////////////////
	//				Logging
	//////////////////////////////////////////
	// Global flag starts at false for security and UX.
	let debug_flag = "false";
	// Need to set the debug() function on page load.
	// Debug mode gets turned off with every page load. This is good for security so leave it.
	setDebug(false);
	// Use a toggle button for usage.
	async function toggleDebug(){
		if( debug_flag === "false"){
			document.getElementById("toggle_debug_button").innerHTML = "Switch to Normal Mode";
			// Toggle global flag.
			debug_flag = "true";
			// Turn on 
			setDebug(true);
			debug("Debug function activated!");
			debug("Warning! Plaintext in console to illustrate Data Flow.");
		} else {
			document.getElementById("toggle_debug_button").innerHTML = "Switch to Debug Mode";
			// Toggle global flag.
			debug_flag = "false";
			// Turn off
			setDebug(false);
			debug("Debug function deactivated! MAJOR ERROR if you can see this! Debug function should be turned off!");
		}
	}

	// Grab currently running HTML and save it to standalone.html
	// This saves the offline dbase in addition to creating and downloading a standalone version that can be used offline.
	function saveOfflineDBase(){
		let allhtml = "<!DOCTYPE HTML>";
		// This will grab a copy of the currently running HTML.
		allhtml += document.querySelector("html").innerHTML;
		//console.log(allhtml);

		let element = document.createElement('a');
		element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(allhtml));
		element.setAttribute('download', 'standalone.html');

		element.style.display = 'none';
		document.body.appendChild(element);

		element.click();

		document.body.removeChild(element);
	}



	// Logging function found on stackoverflow
	// For security, if function setDebug(true) isn't called, debug(log_message) will do nothing.
	function setDebug(isDebug) {
		if (isDebug) {
			// Turn on warning message.
			const titletext = document.getElementById("titletext");
			titletext.style.color = "red";
			titletext.innerHTML = "DEBUGWORD - CAUTION!!!!<br> SENSITIVE DATA WILL BE SHOWN IN CONSOLE";
			// Send a message to the console.
			window.debug = window.console.log.bind(window.console, '%s');
		} else {
			// Turn off warning message.
			const titletext = document.getElementById("titletext");
			titletext.style.color = "#54c597";
			titletext.innerHTML = "SECRETWORD";

			// Do nothing.
			window.debug = function() {};
		}
	}	

	//Uint8Array raw byte input) 
	function to_b58( B ){
		let A = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
		let d = [],   //the array for storing the stream of base58 digits
			s = "",   //the result string variable that will be returned
			i,        //the iterator variable for the byte input
			j,        //the iterator variable for the base58 digit array (d)
			c,        //the carry amount variable that is used to overflow from the current base58 digit to the next base58 digit
			n;        //a temporary placeholder variable for the current base58 digit
		for(i in B) { //loop through each byte in the input stream
			j = 0,                           //reset the base58 digit iterator
			c = B[i];                        //set the initial carry amount equal to the current byte amount
			s += c || s.length ^ i ? "" : 1; //prepend the result string with a "1" (0 in base58) if the byte stream is zero and non-zero bytes haven't been seen yet (to ensure correct decode length)
			while(j in d || c) {             //start looping through the digits until there are no more digits and no carry amount
				n = d[j];                    //set the placeholder for the current base58 digit
				n = n ? n * 256 + c : c;     //shift the current base58 one byte and add the carry amount (or just add the carry amount if this is a new digit)
				c = n / 58 | 0;              //find the new carry amount (floored integer of current digit divided by 58)
				d[j] = n % 58;               //reset the current base58 digit to the remainder (the carry amount will pass on the overflow)
				j++                          //iterate to the next base58 digit
			}
		}
		while(j--)        //since the base58 digits are backwards, loop through them in reverse order
			s += A[d[j]]; //lookup the character associated with each base58 digit
		return s          //return the final base58 string
	}

	//Base58 encoded string input
	function from_b58( S ){
		let A = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
		let d = [],   //the array for storing the stream of decoded bytes
			b = [],   //the result byte array that will be returned
			i,        //the iterator variable for the base58 string
			j,        //the iterator variable for the byte array (d)
			c,        //the carry amount variable that is used to overflow from the current byte to the next byte
			n;        //a temporary placeholder variable for the current byte
		for(i in S) { //loop through each base58 character in the input string
			j = 0,                             //reset the byte iterator
			c = A.indexOf( S[i] );             //set the initial carry amount equal to the current base58 digit
			if(c < 0)                          //see if the base58 digit lookup is invalid (-1)
				return undefined;              //if invalid base58 digit, bail out and return undefined
			c || b.length ^ i ? i : b.push(0); //prepend the result array with a zero if the base58 digit is zero and non-zero characters haven't been seen yet (to ensure correct decode length)
			while(j in d || c) {               //start looping through the bytes until there are no more bytes and no carry amount
				n = d[j];                      //set the placeholder for the current byte
				n = n ? n * 58 + c : c;        //shift the current byte 58 units and add the carry amount (or just add the carry amount if this is a new byte)
				c = n >> 8;                    //find the new carry amount (1-byte shift of current byte value)
				d[j] = n % 256;                //reset the current byte to the remainder (the carry amount will pass on the overflow)
				j++                            //iterate to the next byte
			}
		}
		while(j--)               //since the byte array is backwards, loop through it in reverse order
			b.push( d[j] );      //append each byte to the result
		return new Uint8Array(b) //return the final byte array in Uint8Array format
	}

	//Uint8Array raw byte input
	function to_b58_words( B ){
		let A = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
		let d = [],   //the array for storing the stream of base58 digits
			s = "",   //the result string variable that will be returned
			i,        //the iterator variable for the byte input
			j,        //the iterator variable for the base58 digit array (d)
			c,        //the carry amount variable that is used to overflow from the current base58 digit to the next base58 digit
			n;        //a temporary placeholder variable for the current base58 digit
		for(i in B) { //loop through each byte in the input stream
			j = 0,                           //reset the base58 digit iterator
			c = B[i];                        //set the initial carry amount equal to the current byte amount
			s += c || s.length ^ i ? "" : 1; //prepend the result string with a "1" (0 in base58) if the byte stream is zero and non-zero bytes haven't been seen yet (to ensure correct decode length)
			while(j in d || c) {             //start looping through the digits until there are no more digits and no carry amount
				n = d[j];                    //set the placeholder for the current base58 digit
				n = n ? n * 16 + c : c;     //shift the current base58 one byte and add the carry amount (or just add the carry amount if this is a new digit)
				c = n / 58 | 0;              //find the new carry amount (floored integer of current digit divided by 58)
				d[j] = n % 58;               //reset the current base58 digit to the remainder (the carry amount will pass on the overflow)
				j++                          //iterate to the next base58 digit
			}
		}
		while(j--)        //since the base58 digits are backwards, loop through them in reverse order
			s += A[d[j]]; //lookup the character associated with each base58 digit
		return s          //return the final base58 string
	}

	//Base58 encoded string input
	function from_b58_words( S ){
		let A = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
		let d = [],   //the array for storing the stream of decoded bytes
			b = [],   //the result byte array that will be returned
			i,        //the iterator variable for the base58 string
			j,        //the iterator variable for the byte array (d)
			c,        //the carry amount variable that is used to overflow from the current byte to the next byte
			n;        //a temporary placeholder variable for the current byte
		for(i in S) { //loop through each base58 character in the input string
			j = 0,                             //reset the byte iterator
			c = A.indexOf( S[i] );             //set the initial carry amount equal to the current base58 digit
			if(c < 0)                          //see if the base58 digit lookup is invalid (-1)
				return undefined;              //if invalid base58 digit, bail out and return undefined
			c || b.length ^ i ? i : b.push(0); //prepend the result array with a zero if the base58 digit is zero and non-zero characters haven't been seen yet (to ensure correct decode length)
			while(j in d || c) {               //start looping through the bytes until there are no more bytes and no carry amount
				n = d[j];                      //set the placeholder for the current byte
				n = n ? n * 58 + c : c;        //shift the current byte 58 units and add the carry amount (or just add the carry amount if this is a new byte)
				c = n >> 4;                    //find the new carry amount (1-byte shift of current byte value)
				d[j] = n % 16;                //reset the current byte to the remainder (the carry amount will pass on the overflow)
				j++                            //iterate to the next byte
			}
		}
		while(j--)               //since the byte array is backwards, loop through it in reverse order
			b.push( d[j] );      //append each byte to the result
		//return new Uint8Array(b) //return the final byte array in Uint8Array format
		return new Array(b) //return the final byte array in Uint8Array format
	}

	function wordsToBytes( words ){
		bytes = new Array();
		let bite;
		let upper;
		for(let i = 1; i < words.length; i+=2){
			// add lower bite.
			bite = words[i];
			// add upper 
			upper = words[i-1];
			if( upper >> 3 ){
				upper = upper - 8;
				bite = bite + 128;
			}
			if( upper >> 2 ){
				upper = upper - 4;
				bite = bite + 64;
			}
			if( upper >> 1 ){
				upper = upper - 2;
				bite = bite + 32;
			}
			if( upper ){
				bite = bite + 16;
			}
			bytes.push( bite );
		}
		return bytes;
	}


	function bytesToWords( bytes ){
		words = new Array();
		let upper;
		let lower;
		let bite;

		for(i in bytes) {
			bite = bytes[i];
			upper = 0;
			lower = 0;
			if( bite >> 7 ){ 
				upper += 8;
				bite = bite - 128;
			}
			if( bite >> 6 ){ 
				upper += 4;
				bite = bite - 64;
			}
			if( bite >> 5 ){ 
				upper += 2;
				bite = bite - 32;
			}
			if( bite >> 4 ){ 
				upper += 1;
				bite = bite - 16;
			}
			words.push(upper);
			words.push(bite);
		}
		return words;
	}


</script>

</body>

</html>









