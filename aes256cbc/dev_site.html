<!DOCTYPE HTML>
<html>
<meta content="text/plain;charset=utf-8" http-equiv="Content-Type" />
<meta content="utf-8" http-equiv="encoding" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<head>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap" rel="stylesheet">
</head>
<style>

	* {
		font-family: "Orbitron", serif;
		font-optical-sizing: auto;
		font-weight: 600;
		font-style: normal;
		color: #54c597;
		padding: 5px;
	}

	html {
		background-color: #272727;
	}

	body {
		display: flex;
		flex-direction: column;
		min-height: 100vh;
		margin: 0;
		padding: 0;
	}

	.header {
		display: flex;
		flex-direction: row;
		justify-content: space-between;
		align-items: center;
		color: #54c597;
		padding: 4px;
		padding-right: 10px;
		padding-left: 10px;
	}

	.header_content {
		display: flex;
	}

	.header_title:hover {
		cursor: pointer;
	}

	.header_label {
		padding: 8px;
	}

	.center_html {
		width: 100%;
		background-color: #272727;
		flex: 1 auto;
		display: flex;
		/*align-self: center;*/
	}

	.content_html {
		width: 100%;
		display: flex;
		/*align-items: baseline;*/
		justify-content: center;
	}

	/* generated conetent */
	.gen {
		width: 700px;
		margin: 10px;
		align-self: center;
		display: flex;
		flex-direction: column;
		justify-content: center; 
		color: #54c597;
	}

	/* default button styling. HTML style="" will override. */
	button {
		/*width: 400px;*/
		height: 65px;
		background-color: #434343;
		border: 2px solid;
		padding: 2px;
		margin: 8px;
		padding-right: 10px;
		padding-left: 10px;
		color: #54c597;
		border-color: #54c597;
		font-size: 17px;
		border-radius: 15px;
	}

	input[type="password"] {
		height: 80px;
		width: 95%;
		background-color: #272727;
		border: 2px solid;
		padding: 8px;
		margin: 8px;
		border-color: #54c597;
		color: #54c597;
		font-size: 25px;
		border-radius: 20px;
	}

	a {
		font-family: Arial, Helvetica, sans-serif;
		font-size: 16px;
		color: blue;
	}

	p {
		font-family: Arial, Helvetica, sans-serif;
		font-size: 16px;
		color: black;
	}

	/* Change the textareas inside divs with 'gen' class to the following: */
	.gen textarea {
		width: 95%;
		height: 150px;
		background-color: #272727;
		border: 2px solid;
		padding: 12px;
		margin: 8px;
		border-color: #54c597;
		color: #54c597;
		font-size: 25px;
		border-radius: 30px;
	}

	/* 'Are you sure?' overlay */
	.deletecheck {
		justify-content:center;
		align-items:center;
		z-index:10;
		position:absolute;
		width:100%;
		height:215%;
		display:none;
		background-color:gray;
		padding:8px;
		margin-left:0;
		margin-top:-40%;
		flex-direction: column;
		border:2px solid;
		border-color:red; 
		border-radius:30px;
	}

	.devsite_inputs {
		font-family: Arial, Helvetica, sans-serif;
		font-size: 16px;
		color: black;
		background-color: grey;
	}

	.tooltip {
		font-family: Arial, Helvetica, sans-serif;
		font-size: 16px;
		color: black;
	}

	/* Add this class to a span or label (and other types?) to make it a cool looking pink */
	.coolpink {
		color:#ff00ff;
		text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
	}

	.openssl_encrypt_flowchart {
		background-image: url('./svg_images/openssl_encrypt_flowchart.drawio.svg');
	}

	.openssl_decrypt_flowchart {
		background-image: url('./svg_images/openssl_decrypt_flowchart.drawio.svg');
	}

	/* Makes the background color blend from orange to #AEE850 */
	.glossy_button {
		background: linear-gradient(orange, #aee850);
		border: 1px solid #1d6511;
		color: black;
		font-size: 12px;
		height: 30px;
		cursor: pointer;
	}

	/* Makes the text blend from orange to #AEE850 */
	/* background-clip: text creates a 'cut-out' of the background where the text exists, creating text with a linear gradient.*/
	.glossy_icon {
		background-image: linear-gradient(orange, #aee850);
		color: transparent;
		background-clip: text;
	}

	/* Set minimum page Width to */
	@media screen and (max-width: 340px){ html,body {min-width: 340px} }

	/* Set minimum page Height to 400 */
	@media screen and (max-height: 400px){ html,body {min-height: 400px} }	

	/* Responsive Design: When the viewport is fewer than 700px wide, activate the following CSS. */
	@media screen and (max-width:700px) {

		input[type="password"] {
			width: 90%;
		}

		textarea {
			width: 90%;
		}

		.header {
			flex-direction: column;
		}

		.home button {
			width: 200px;
			/*border-color: black;*/
		}

		.home_buttons {
			/*flex-direction: column;*/
		}

		.choose button {
			font-size: 14px;
		}

		.upload input {
			font-size: 16px;
		}

		.deletecheck {
			margin-top: -50%;
			height: 220%;
		}
		
		.content_html {
			margin-top: -100px;
		}
	}
	@media screen and (max-width:500px) {
/*
		input {
			width: 400px;
		}

		textarea {
			width: 400px;
		}
*/
		.home button {
			width: 150px;
			font-size: 14px;
			/*border-color: black;*/
		}

		.deletecheck {
			width: 95%;
			margin-top: -75%;
			height:250%;
		}
	}

</style>
<body>
<button id="toggle_site_button" onclick="toggleSite()">Show Main Site</button>
<div id="main_site" style="display:none;">

	<div class="header" id="header">
		<div class="header_content" id="header_left">
			<div class="header_title">
				<a id="titletext" style="font-size:30px; text-decoration:underline;" >SECRETWORD</a>
				<!--<a id="titletext" style="font-size:30px" href="/obf">SECRETWORD</a>--!>
			</div>
		</div>
		<div class="header_content" id="header_right">
			<div class="header_label" style="">
				<label id="howworks">HOW IT WORKS</label>
			</div>
			<div class="header_label" style="">
				<label id="faq">FAQ</label>
			</div>
		</div>
	</div>
	<div id="offline_status_div" style="display:flex; justify-content:space-between;">
		<label id="offline_label" style="" >YOU'RE OFFLINE. SERVER WILL NOT BE UPDATED WITH ANY NEW SAVES.</label>
	</div>
	<div id="full_offline_dbase_warning_div" style="display:flex; justify-content:space-between;">
		<label id="full_offline_dbase_warning" style="display:none; color:red;" >YOUR OFFLINE DATABASE IS NOW FULL. ADDITIONAL STORES WILL NOT BE SAVED TO IT. IF ADDITIONAL STORAGE IS NEEDED, PLEASE INITIALIZE A NEW OFFLINE DATABASE (AFTER PROPERLY STORING THIS ONE).</label>
	</div>
	<div class="center_html" id="center_html" style="height:100%">
		<div class="content_html" id="content_html">

			<!--<TMPL_VAR NAME=htmlblock>--!>

<!--  home  --!>
			<div class="gen home" id="home" style="align-self:center; display:none; flex-direction:column; justify-content:center; color:#54c597">
				<h2>SECURELY STORE DATA AND ACCESS FROM ANY WEB BROWSER</h2>
				<div class="home_buttons" id="" style="display:flex; justify-content:center;">
					<button class="obf_button" id='go_store_thread' style="flex-grow:1" onclick="securityReset();showPage('store1')">STORE SECRET DATA</button>
					<button class="obf_button" id='go_load_thread' style="flex-grow:1" onclick="securityReset();showPage('load1')">ACCESS SECRET DATA</button>
				</div>
			</div>
<!--  home  --!>

<!--  store  --!>
			<div class="gen store one" id="store1" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>STORE DATA</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<h2>ENTER CODE WORD TO HELP YOU REMEMBER YOUR SECRET DATA</h2>
				<input type="password" autocomplete="off" autofocus id="store_codeword" style="">
				<div class="button_pair" id="" style="display:flex">
					<button class="" id='' style="flex-grow:1" onclick="showPage('home')">BACK</button>
					<button class="" id='' style="flex-grow:1" onclick="checkPassLength('store1','store_choose')">NEXT</button>
				</div>
			</div>

			<div class="gen store choose" id="store_choose" style="display:none">
				<label>STORE DATA</label>
				<h2 style="align-self:center;">CHOOSE WHERE TO ENCRYPT YOUR DATA</h2>
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1" onclick="showPage('store1')">BACK</button>
					<div class="informative_button_set" id="" style="flex-grow:3; display:flex; display:flex; flex-direction:column;">
						<button class="" id='' style="display:flex; flex-direction:column; justify-content:center; align-items:center;" onclick="storeDefault()">
							<span style="">BROWSER</span>
							<span style="margin-top:4px; color:gray; font-size:15px;">Text Input</span>
						</button>
					</div>
					<div class="informative_button_set" id="" style="flex-grow:3; display:flex; display:flex; flex-direction:column;">
						<button class="" id='' style="display:flex; flex-direction:column; justify-content:center;" onclick="storeUpload()">
							<span class="coolpink" style="">COMMAND LINE</span>
							<span style="margin-top:4px; color:gray; font-size:15px;">File Input</span>
						</button>
						<label class="coolpink" style="align-self:center;">More Secure</label>
					</div>
				</div>
			</div>

			<div class="gen store upload" id="store_upload" style="display:none">
				<label>STORE DATA</label>
				<h2>UPLOAD FILE</h3>
				<h2 id="store_upload_warning" style="color:red; display:none">FILE TOO LARGE. 700 byte limit</h2>
				<input autocomplete="off" onchange="catchUpload(event)" id="store_upload_input" style="border:none;" type="file">
				<br>
				<label>OpenSSL Linux <span class="coolpink" style="">Command Line</span> Usage:</label>
				<div style='display:flex; flex-direction:column; border-style:inset; width:fit-content; padding:5px;'>
					<label>Encrypt:</label>
					<label>openssl enc -aes-256-cbc <span class="coolpink" style="">-e</span> -pbkdf2 -in <span class="coolpink">yourfile.txt</span> -out <span class="coolpink">yourfile.enc</span></label>
					<br>
					<label>Decrypt:</label>
					<label>openssl enc -aes-256-cbc <span class="coolpink" style="">-d</span> -pbkdf2 -in <span class="coolpink">yourfile.enc</span> -out <span class="coolpink">yourfile.txt</span></label>
				</div>
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="width:250px;" onclick="showPage('store_choose')">BACK</button>
					<button class="" id='store_upload_continue' style="flex-grow:1;display:none;" onclick="showPage('store4')">CONTINUE</button>
				</div>
			</div>

			<div class="gen store two" id="store2" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>STORE DATA</label>
					<label id="data_length_label" style="color:black" ></label>
				</div>
				<textarea class="browser_input" value="" id="store_data" rows="8" cols="45" oninput="checkTextInputLength('store_data')" placeholder="ENTER YOUR SECRET DATA"></textarea>
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1" onclick="showPage('store_choose')">BACK</button>
					<button class="" id='text_input_continue' style="flex-grow:1" onclick="showPage('store3')">ENCRYPT DATA</button>
					<div id='text_input_warning' style="flex-grow:1;display:none;">
						<h2 id='' style="color:red;">TOO MUCH DATA</h2>
					</div>
				</div>
			</div>

			<div class="gen store three" id="store3" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>STORE DATA</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<label>&#10004; SECRET DATA SAVED</label>
				<h2>ENTER SECRET WORD 1</h2>
				<input autocomplete="off" type="password" value="" id="store_pass_1" style="">
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1;" onclick="showPage('store2')">BACK</button>
					<button class="" id='' style="flex-grow:1;" onclick="checkPassLength('store3','store4')">ENHANCE SECURITY</button>
				</div>
			</div>

			<div class="gen store four" id="store4" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>STORE DATA</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<label>&#10004; SECRET DATA SAVED</label>
				<label>&#10004; SECRET WORD 1 SAVED</label>
				<h2>ENTER SECRET WORD 2</h2>
				<input autocomplete="off" type="password" value="" id="store_pass_2" style="">
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1;" onclick="storeBack()">BACK</button>
					<button class="" id='' style="flex-grow:1;" onclick="checkPassLength('store4','store5')">ENHANCE SECURITY</button>
				</div>
			</div>

			<div class="gen store five" id="store5" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>STORE DATA</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<label>&#10004; SECRET DATA SAVED</label>
				<label>&#10004; SECRET WORD 1 SAVED</label>
				<label>&#10004; SECRET WORD 2 SAVED</label>
				<h2>ENTER SECRET WORD 3</h2>
				<input autocomplete="off" type="password" value="" id="store_pass_3" style="">
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1;" onclick="showPage('store4')">BACK</button>
					<button class="" id='deepstorebutton' style="flex-grow:1;" onclick="checkPassLength('store5','executeStore')">DEEP STORE DATA</button>
				</div>
			</div>

			<div class="gen store six" id="store6" style="display:none">
				<h2>&#10004; SECRET DATA SUCCESSFULLY STORED AND ENCRYPTED</h2>
				<div class="button_pair" id="" style="display:flex;">
					<!--<button class="" id='learnmore' style="flex-grow:1;" onclick="location.href='/obf/how';">LEARN MORE</button>--!>
					<button class="" id='go_store' style="flex-grow:1;" onclick="securityReset();showPage('store1')">STORE DATA</button>
					<button class="" id='accessdata' style="flex-grow:1;" onclick="securityReset();showPage('load1')">ACCESS DATA</button>
				</div>
			</div>

			<div class="gen store seven" id="store7" style="display:none">
				<h2>&#10060; FAILED TO STORE</h2>
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='go_store' style="flex-grow:1;" onclick="securityReset();showPage('store1')">STORE DATA</button>
					<button class="" id='accessdata' style="flex-grow:1" onclick="securityReset();showPage('load1')">ACCESS DATA</button>
				</div>
			</div>

			<div class="gen store eight" id="store8" style="display:none">
				<h2>&#10004; SUCCESSFULLY STORED TO OFFLINE DATABASE BUT:</h2>
				<h2>&#10060; FAILED TO STORE TO SERVER</h2>
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='go_store' style="flex-grow:1;" onclick="securityReset();showPage('store1')">STORE DATA</button>
					<button class="" id='accessdata' style="flex-grow:1" onclick="securityReset();showPage('load1')">ACCESS DATA</button>
				</div>
			</div>

			<div class="gen store nine" id="store9" style="display:none">
				<h2>&#10060; FAILED TO STORE TO OFFLINE DATABASE BECAUSE IT'S FULL BUT:</h2>
				<h2>&#10004; SUCCESSFULLY STORED TO SERVER</h2>
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='go_store' style="flex-grow:1;" onclick="securityReset();showPage('store1')">STORE DATA</button>
					<button class="" id='accessdata' style="flex-grow:1" onclick="securityReset();showPage('load1')">ACCESS DATA</button>
				</div>
			</div>

	<!-- Catch Upload Data --!>
	<input autocomplete="off" type="password" value="" id="upload_data" style="display:none;">
<!--  store  --!>

<!--  load  --!>
			<div class="gen load one" id="load1" style="display:none;">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>ACCESS DATA</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<h2>ENTER CODE WORD</h2>
				<input autocomplete="off" type="password" autofocus  value="" id="load_codeword" style="">
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1;" onclick="showPage('home')">BACK</button>
					<button class="" id='' style="flex-grow:1" onclick="checkPassLength('load1','load_choose')">NEXT</button>
				</div>
			</div>

			<div class="gen load choose" id="load_choose" style="display:none">
				<label>ACCESS DATA</label>
				<h2 style="align-self:center;">CHOOSE WHERE TO DECRYPT YOUR DATA</h2>
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1" onclick="showPage('load1')">BACK</button>
					<div class="informative_button_set" id="" style="flex-grow:3; display:flex; display:flex; flex-direction:column;">
						<button class="" id='' style="display:flex; flex-direction:column; justify-content:center; align-items:center;" onclick="loadDefault()">
							<span style="">BROWSER</span>
							<span style="margin-top:4px; color:gray; font-size:15px;">Text Output</span>
						</button>
					</div>
					<div class="informative_button_set" id="" style="flex-grow:3; display:flex; display:flex; flex-direction:column;">
						<button class="" id='' style="display:flex; flex-direction:column; justify-content:center;" onclick="loadDownload()">
							<span style="color:#ff00ff;text-shadow:-1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;">COMMAND LINE</span>
							<span style="margin-top:4px; color:gray; font-size:15px;">File Output</span>
						</button>
						<label style="align-self:center; color:#ff00ff;text-shadow:-1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;">More Secure</label>
					</div>
				</div>
			</div>

			<div class="gen load two" id="load2" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>ACCESS DATA</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<label>&#10004; CODE WORD ENTERED</label> 
				<h2>ENTER SECRET WORD 1</h2>
				<input autocomplete="off" type="password"  value="" id="load_pass_1" style="">
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1" onclick="showPage('load_choose')">BACK</button>
					<button class="" id='' style="flex-grow:1" onclick="checkPassLength('load2','load3')">NEXT</button>
				</div>
			</div>

			<div class="gen load three" id="load3" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>ACCESS DATA</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<label>&#10004; CODE WORD ENTERED</label> 
				<label>&#10004; SECRET WORD 1 ENTERED</label> 
				<h2>ENTER SECRET WORD 2</h2>
				<input autocomplete="off" type="password"  value="" id="load_pass_2" style="">
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1" onclick="loadBack()">BACK</button>
					<button class="" id='' style="flex-grow:1" onclick="checkPassLength('load3','load4')">NEXT</button>
				</div>
			</div>

			<div class="gen load four" id="load4" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>ACCESS DATA</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<label>&#10004; CODE WORD ENTERED</label> 
				<label>&#10004; SECRET WORD 1 ENTERED</label> 
				<label>&#10004; SECRET WORD 2 ENTERED</label> 
				<h2>ENTER SECRET WORD 3</h2>
				<input autocomplete="off" type="password"  value="" id="load_pass_3" style="">
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1" onclick="showPage('load3')">BACK</button>
					<button class="" id='' style="flex-grow:1;" onclick="checkPassLength('load4','executeLoad')">ACCESS DATA</button>
				</div>
			</div>

			<div class="gen load text" id="load_text" style="display:none">
				<label>&#10004; SUCCESS</label>
				<label>result:</label>
				<div class="overlay_container" style="position:relative">
					<textarea value="" id="output_display" rows="8" cols="50"></textarea>
					<div id="overlay_text" class="deletecheck" style="">
						<h2>Are you sure you want to delete this data?</h2> 
						<div class="button_pair" id="" style="display:flex;">
							<button class="" id='' style="flex-grow:1" onclick="deleteCheckHide('overlay_text')">KEEP DATA</button>
							<button class="" id='' style="flex-grow:1;" onclick="deleteExecute()">DELETE DATA</button>
						</div>
					</div>
				</div>
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='go_store' style="flex-grow:1;" onclick="securityReset();showPage('store1')">STORE DATA</button>
					<button class="" id='go_load' style="flex-grow:1;" onclick="securityReset();showPage('load1')">ACCESS DATA</button>
					<button class="" id='' style="flex-grow:1" onclick="deleteCheckShow('overlay_text')">DELETE DATA</button>
				</div>
			</div>

			<div class="gen load download" id="load_download" style="display:none">
				<label>&#10004; SUCCESS</label>
				<label>File should automatically download.</label>
				<br>
				<div class="overlay_container" style="position:relative">
					<label>OpenSSL Linux <span class="coolpink" style="">Command Line</span> Usage:</label>
					<div style='display:flex; flex-direction:column; border-style:inset; width:fit-content; padding:5px;'>
						<label>Encrypt:</label>
						<label>openssl enc -aes-256-cbc <span class="coolpink" style="">-e</span> -pbkdf2 -in <span class="coolpink">yourfile.txt</span> -out <span class="coolpink">yourfile.enc</span></label>
						<br>
						<label>Decrypt:</label>
						<label>openssl enc -aes-256-cbc <span class="coolpink" style="">-d</span> -pbkdf2 -in <span class="coolpink">yourfile.enc</span> -out <span class="coolpink">yourfile.txt</span></label>
					</div>
					<div id="overlay_download" class="deletecheck" style="">
						<h2>Are you sure you want to delete this data?</h2> 
						<div class="button_pair" id="" style="display:flex;">
							<button class="" id='' style="flex-grow:1" onclick="deleteCheckHide('overlay_download')">KEEP DATA</button>
							<button class="" id='' style="flex-grow:1;" onclick="deleteExecute()">DELETE DATA</button>
						</div>
					</div>
				</div>
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='go_store' style="flex-grow:1;" onclick="securityReset();showPage('store1')">STORE DATA</button>
					<button class="" id='go_load' style="flex-grow:1;" onclick="securityReset();showPage('load1')">ACCESS DATA</button>
					<button class="" id='' style="flex-grow:1" onclick="deleteCheckShow('overlay_download')">DELETE DATA</button>
				</div>
			</div>

			<div class="gen failed_to_access" id="failed_to_access" style="display:none">
				<label>&#10005; FAILED TO ACCESS</label>
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='go_store' style="flex-grow:1;" onclick="securityReset();showPage('store1')">STORE DATA</button>
					<button class="" id='go_load' style="flex-grow:1;" onclick="securityReset();showPage('load1')">ACCESS DATA</button>
				</div>
			</div>
<!--  load  --!>

<!--  delete --!>
			<div class="gen delete five" id="delete5" style="display:none">
				<label>&#10004; SUCCESS</label>
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='go_store' style="flex-grow:1;" onclick="securityReset();showPage('store1')">STORE DATA</button>
					<button class="" id='go_load' style="flex-grow:1;" onclick="securityReset();showPage('load1')">ACCESS DATA</button>
				</div>
			</div>

			<div class="gen delete six" id="delete6" style="display:none">
				<h2>&#10004; SUCCESSFULLY DELETED FROM OFFLINE DATABASE BUT:</h2>
				<h2>&#10060; FAILED TO DELETE FROM SERVER</h2>
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='go_store' style="flex-grow:1;" onclick="securityReset();showPage('store1')">STORE DATA</button>
					<button class="" id='go_load' style="flex-grow:1;" onclick="securityReset();showPage('load1')">ACCESS DATA</button>
				</div>
			</div>

			<div class="gen delete seven" id="delete7" style="display:none">
				<h2>&#10060; FAILED TO DELETE</h2>
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='go_store' style="flex-grow:1;" onclick="securityReset();showPage('store1')">STORE DATA</button>
					<button class="" id='go_load' style="flex-grow:1;" onclick="securityReset();showPage('load1')">ACCESS DATA</button>
				</div>
			</div>
<!--  delete --!>

						<!------ Create New Offline DBase  ---!>
			<div id="create_new_offline_dbase_div" class="gen" style="display:none; ">
				<h2 id="create_offline_dbase_label_h2">THIS WILL CREATE AN OFFLINE DATABASE OF PREVIOUSLY STORED DATA.</h2>
				<h3 id="create_offline_dbase_label_h3">Please enter the following passwords to Access the data you wish to be stored in the offline database.</h3>
				<div style="display:flex; flex-direction:column;">
					<label id="">ENTER CODEWORD:</label>
					<input autocomplete="off" type="password"  value="" id="gather_codeword" style="">
					<label id="">ENTER PASSWORD 2:</label>
					<input autocomplete="off" type="password"  value="" id="gather_password2" style="">
					<label id="">ENTER PASSWORD 3:</label>
					<input autocomplete="off" type="password"  value="" id="gather_password3" style="">
				</div>
				<div style="display:flex; flex-direction:row;">
					<button id="new_offline_dbase_access_data_button" style="flex-grow:1; " onclick="accessDataForOfflineDBaseCreation()">SUBMIT PASSWORDS</button>
					<button id="new_offline_dbase_cancel_button" style="flex-grow:1; " onclick="cancelNewOfflineDBase()">CANCEL</button>
					<button id="new_offline_dbase_completed_button" style="flex-grow:1; display:none;" onclick="doneNewOfflineDBase()">DONE</button>
				</div>
				<h3 id="status_label" style="align-self:center; display:none; color:red;">placeholder</h3>
			</div>

<!------------------------------------ Passlock Steps --------------------------------------------------------------------------!>

			<!---------------------------Pass 1-----------------------!>
			<div class="gen passlock" id="passlock1" style="display:flex">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>PASSLOCK PROTOTYPE THREAD</label>
					<label>PASS 1</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<h2>ENTER SECRET WORD 1</h2>
				<input autocomplete="off" type="password" value="" id="passlock_pass1" style="">
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1;" onclick="showPage('passlock1')">BACK</button>
					<!----<button class="" id='' style="flex-grow:1;" onclick="checkPassLength('passlock1','passlock2')">CONTINUE</button>---!>
					<button class="" id='' style="flex-grow:1;" onclick="initiatePasslock('passlock_pass1');showPage('passlock2');">CONTINUE</button>
					<!--<button class="" id='' style="flex-grow:1;" onclick="generatePasslock();passlockAdd('passlock_pass1');showPage('passlock2');">CONTINUE</button>--!>
				</div>
			</div>

			<!---------------------------Pass 2-----------------------!>
			<div class="gen passlock" id="passlock2" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>PASSLOCK PROTOTYPE THREAD</label>
					<label>PASS 2</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<h2>ENTER SECRET WORD 2</h2>
				<input autocomplete="off" type="password" value="" id="passlock_pass2" style="">
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1;" onclick="showPage('passlock1')">BACK</button>
					<!--<button class="" id='' style="flex-grow:1;" onclick="checkPassLength('passlock2','passlock3')">CONTINUE</button>--!>
					<button class="" id='' style="flex-grow:1;" onclick="passlockAdd('passlock_pass2');showPage('passlock3');">CONTINUE</button>
				</div>
			</div>

			<!---------------------------Pass 3-----------------------!>
			<div class="gen passlock" id="passlock3" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>PASSLOCK PROTOTYPE THREAD</label>
					<label>PASS 3</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<h2>ENTER SECRET WORD 3</h2>
				<input autocomplete="off" type="password" value="" id="passlock_pass3" style="">
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1;" onclick="showPage('passlock2')">BACK</button>
					<button class="" id='' style="flex-grow:1;" onclick="passlockAdd('passlock_pass3');showPage('passlock_cw');">CONTINUE</button>
				</div>
			</div>

			<!---------------------------Codeword-----------------------!>
			<div class="gen passlock" id="passlock_cw" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>PASSLOCK PROTOTYPE THREAD</label>
					<label>CODEWORD</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<h2>ENTER CODEWORD</h2>
				<input autocomplete="off" type="password" value="" id="passlock_codeword" style="">
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1;" onclick="showPage('passlock3')">BACK</button>
					<button class="" id='' style="flex-grow:1;" onclick="passlockAdd('passlock_codeword');showPage('check_passlock1')">CONTINUE</button>
				</div>
			</div>

			<!---------------------------Check Pass 1-----------------------!>
			<div class="gen passlock" id="check_passlock1" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>PASSLOCK PROTOTYPE THREAD</label>
					<label>CHECK PASS 1</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<label class="pass_check_warning" style="color:red; display:none;">Passwords don't match!</label>
				<h2>RE-ENTER SECRET WORD 1</h2>
				<input autocomplete="off" type="password" value="" id="check_pass1" style="">
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1;" onclick="showPage('passlock_cw')">BACK</button>
					<button class="" id='' style="flex-grow:1;" onclick="checkPasslock(0, 'check_pass1', 'check_passlock1', 'check_passlock2')">CONTINUE</button>
				</div>
			</div>

			<!---------------------------Check Pass 2-----------------------!>
			<div class="gen passlock" id="check_passlock2" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>PASSLOCK PROTOTYPE THREAD</label>
					<label>CHECK PASS 2</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<label class="pass_check_warning" style="color:red; display:none;">Passwords don't match!</label>
				<h2>RE-ENTER SECRET WORD 2</h2>
				<input autocomplete="off" type="password" value="" id="check_pass2" style="">
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1;" onclick="showPage('check_passlock1')">BACK</button>
					<button class="" id='' style="flex-grow:1;" onclick="checkPasslock(1, 'check_pass2', 'check_passlock2', 'check_passlock3')">CONTINUE</button>
				</div>
			</div>

			<!---------------------------Check Pass 3-----------------------!>
			<div class="gen passlock" id="check_passlock3" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>PASSLOCK PROTOTYPE THREAD</label>
					<label>CHECK PASS 3</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<label class="pass_check_warning" style="color:red; display:none;">Passwords don't match!</label>
				<h2>RE-ENTER SECRET WORD 3</h2>
				<input autocomplete="off" type="password" value="" id="check_pass3" style="">
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1;" onclick="showPage('check_passlock2')">BACK</button>
					<button class="" id='' style="flex-grow:1;" onclick="checkPasslock(2, 'check_pass3', 'check_passlock3', 'check_cw')">CONTINUE</button>
				</div>
			</div>

			<!---------------------------Check Codeword-----------------------!>
			<div class="gen passlock" id="check_cw" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>PASSLOCK PROTOTYPE THREAD</label>
					<label>CHECK CODEWORD</label>
					<label class="pass_length_warn" style="color:red; display:none;">Password too short!</label>
				</div>
				<label class="pass_check_warning" style="color:red; display:none;">Passwords don't match!</label>
				<h2>RE-ENTER CODEWORD</h2>
				<input autocomplete="off" type="password" value="" id="check_codeword" style="">
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1;" onclick="showPage('check_passlock3')">BACK</button>
					<button class="" id='' style="flex-grow:1;" onclick="checkPasslock(3, 'check_codeword', 'check_cw', 'passlock_data')">CONTINUE</button>
				</div>
			</div>

			<!---------------------------Data-----------------------!>
			<div class="gen passlock" id="passlock_data" style="display:none">
				<div style="display:flex; flex-direction:row; justify-content:space-between;">
					<label>PASSLOCK PROTOTYPE THREAD</label>
					<label>STORE DATA</label>
					<label id="data_length_label" style="color:black"></label>
				</div>
				<textarea class="browser_input" id="passlock_data_textarea" rows="8" cols="45" oninput="checkTextInputLength('passlock_data')" placeholder="ENTER YOUR SECRET DATA"></textarea>
				<div class="button_pair" id="" style="display:flex;">
					<button class="" id='' style="flex-grow:1" onclick="showPage('check_cw')">BACK</button>
					<button class="" id='text_input_continue' style="flex-grow:1" onclick="commitDataToServer('passlock_data_textarea')">ENCRYPT DATA AND COMMIT TO SERVER</button>
					<div id='text_input_warning' style="flex-grow:1;display:none;">
						<h2 id='' style="color:red;">TOO MUCH DATA</h2>
					</div>
				</div>
			</div>

			<!---------------------------REITERATION STEP -----------------------!>
			<div class="gen passlock" id="passlock_reiteration" style="display:none;">
				<h2 id="">This is the REITERATION Step</h2>
				<h3 id="">Eloquent text explaining how this works.</h3>
				<div style="display:flex; flex-direction:column;">
					<label id="">PASSWORD 1 (maybe this appears only if you've chosen browser?):</label>
					<div style="display:flex;">
						<input id="reiteration_pass1" autocomplete="off" type="password" value="" style="">
						<button id="show_reiteration_pass1" style="" onclick="showPassword('pass1')">SHOW</button>
					</div>
					<label id="">PASSWORD 2:</label>
					<div style="display:flex;">
						<input id="reiteration_pass2" autocomplete="off" type="password" value="" style="">
						<button id="show_reiteration_pass2" style="" onclick="showPassword('pass2')">SHOW</button>
					</div>
					<label id="">PASSWORD 3:</label>
					<div style="display:flex;">
						<input id="reiteration_pass3" autocomplete="off" type="password" value="" style="">
						<button id="show_reiteration_pass3" style="" onclick="showPassword('pass3')">SHOW</button>
					</div>
					<label id="">CODEWORD:</label>
					<div style="display:flex;">
						<input id="reiteration_codeword" autocomplete="off" type="password" value="" style="">
						<button id="show_reiteration_codeword" style="" onclick="showPassword('codeword')">SHOW</button>
					</div>
				</div>
				<div style="display:flex; flex-direction:row;">
					<button id="reiteration_cancel" style="flex-grow:1; " onclick="showPage('passlock_cw')">BACK</button>
					<button id="reiteration_commit" style="flex-grow:1; " onclick="showPage('')">READY TO STORE DATA</button>
				</div>
				<h3 id="status_label" style="align-self:center; display:inline; color:red;">Errors, important information can go here.</h3>
			</div>
<!------------------------------------ Passlock Steps --------------------------------------------------------------------------!>

		</div>		<!-- content_html --!>
	</div>			<!-- center_html --!>


<!-------------------------------------------- Footer Buttons ----------------------------------------------------!>
	<div style="display:flex; flex-direction:column;">
		<button id="create_dbase_button" style="display:inline; flex-grow:1" onclick="createNewOfflineDBaseThread()">CREATE NEW OFFLINE DBASE</button>
		<div style="display:flex">
			<button id="toggle_debug_button" style="flex-grow:1" onclick="toggleDebug()">SWITCH TO DEBUG MODE</button>
			<button id="download_offline_dbase_button" style="flex-grow:1" onclick="saveOfflineDBase()">DOWNLOAD STANDALONE.HTML</button>
		</div>
	</div>
<!-------------------------------------------- Footer Buttons ----------------------------------------------------!>

	<!-- Offline Database Data --!>
	<p id="offline_dbase" style="display:none"></p>
	<p id="offline_dbase_pointer" style="display:none"></p>
	<!-- Offline Database flag that we need to do a burst store when we come back online --!>
	<p id="offline_dbase_update_flag" style="display:none"></p>
</div>

<!-- Dev Site --!>
<!-- Dev Site --!>
<!-- Dev Site --!>
<!-- Dev Site --!>
<!-- Dev Site --!>
<!-- Dev Site --!>
<!-- Dev Site --!>
<!-- Dev Site --!>
<!-- Dev Site --!>
<!-- Dev Site --!>
<!-- Dev Site --!>
<div class="" id="dev_site" style="display:inline">
	<h2 class="header_title">Development Site -- Crypto Functions</h2>

	<!-- OpenSSL Encrypt -->
	<h3 style="color:black;">OpenSSL Encrypt<a class="glossy_icon" style="" href="javascript:void('show tooltip')" onclick="showTipOpenSSLTitle()" >[?]</a></h3>
	<div style="position:relative; border:1px solid; width:1010px;">
		<img src="./svg_images/openssl_encrypt_flowchart.drawio.svg" style="width:1000px;" alt="OpenSSL Encrypt" />

		<!-- Tooltip Object for OpenSSL Encrypt--!>
		<div class="" id="dev_enc_openssl_tooltip" style="z-index:2; display:none; position:absolute; top:100px; left:100px; background-color:lightgray; border:5px solid gold;"></div>

		<input id="dev_enc_openssl_password_input" class="devsite_inputs" type="text" style="position:absolute; top:40px; left:20px; width:350px;">
		<input id="dev_enc_openssl_password_bytes" class="devsite_inputs" type="text" style="position:absolute; top:116px; left:20px; width:350px;">

		<!--<input id="dev_enc_openssl_derivebits_algorithm" class="devsite_inputs" type="text" value="PBKDF2" style="position:absolute; top:316px; left:20px; width:183px; height:10px;">--!>
		<input id="dev_enc_openssl_derivebits_salt" class="devsite_inputs" type="text" style="position:absolute; top:260px; left:26px; width:183px; height:10px;">
		<input id="dev_enc_openssl_derivebits_iterations" class="devsite_inputs" type="text" value="10000" style="position:absolute; top:310px; left:26px; width:183px; height:10px;">
		<!--<input id="dev_enc_openssl_derivebits_hash" class="devsite_inputs" type="text" value="SHA-256" style="position:absolute; top:470px; left:20px; width:183px; height:10px;">--!>

		<!-- Might use a different graphic for this.
		<a class="glossy_icon" style="position:absolute; top:150px; left:500px;" href="javascript:void('show tooltip')" onclick="showTipOpenSSLTitle()" >[?]</a>-->

		<a class="glossy_icon" style="position:absolute; top:165px; left:970px;" href="javascript:void('show tooltip')" onclick="showTipNewline()" >[?]</a>

		<button class="glossy_button" style="position:absolute; top:150px; left:500px;" onclick="showTipBinary()">Why binary shows up like this</button>
		<!--<button class="glossy_button" style="position:absolute; top:180px; left:770px;" onclick="showTipNewline()">Why newline byte needed</button>-->

		<button class="glossy_button" style="position:absolute; top:250px; left:318px;" onclick="showTipImportKeyEnc()">IMPORT KEY</button>

		<button class="glossy_button" id="dev_enc_openssl_manual_salt_button" style="position:absolute; top:230px; left:106px; width:100px; height:20px; font-size:10px;" onclick="devManualSalt()">Roll Salt</button>
		<div style="background-color:cornflowerblue; font-size:14px; position:absolute; top:360px; left:20px; ">
			<fieldset >
				<legend style="color:black;">Digest Hash:</legend>
				<div>
					<input type="radio" id="SHA-256" name="digest_hash" value="SHA-256" checked />
					<label style="color:black;" for="SHA-256">SHA-256</label>
				</div>
				<div>
					<input type="radio" id="SHA-384" name="digest_hash" value="SHA-384" />
					<label style="color:black;" for="SHA-384">SHA-384</label>
				</div>
				<div>
					<input type="radio" id="SHA-512" name="digest_hash" value="SHA-512" />
					<label style="color:black;" for="SHA-512">SHA-512</label>
				</div>
			</fieldset>
		</div>

		<button class="glossy_button" style="position:absolute; top:415px; left:270px; " onclick="showTipEncDeriveBits()">DERIVE BITS</button>
		<input id="dev_enc_openssl_encrypt_algorithm" class="devsite_inputs" type="text" value="AES-CBC" style="position:absolute; top:304px; left:578px; width:128px; height:10px;">
		<textarea id="dev_enc_openssl_encrypt_iv" class="devsite_inputs" rows="2" style="position:absolute; top:357px; left:540px; width:265px; height:34px;"></textarea>
		<textarea id="dev_enc_openssl_encrypt_key" class="devsite_inputs" rows="3" style="position:absolute; top:445px; left:439px; width:350px; height:48px;"></textarea>

		<input id="dev_enc_openssl_plaintext_input" class="devsite_inputs" type="text" style="position:absolute; top:40px; left:465px; width:525px;">
		<input id="dev_enc_openssl_plaintext_bytes" class="devsite_inputs" type="text" style="position:absolute; top:116px; left:465px; width:525px;">
		<input id="dev_enc_openssl_plaintext_with_newline" class="devsite_inputs" type="text" style="position:absolute; top:230px; left:465px; width:525px;">

		<button class="glossy_button" style="position:absolute; top:415px; left:900px; " onclick="showTipEncEncrypt()">ENCRYPT</button>
		<input id="dev_enc_openssl_encrypted_data" class="devsite_inputs" type="text" style="position:absolute; top:542px; left:340px; width:642px;">
		<input id="dev_enc_openssl_encrypted_salt_string" class="devsite_inputs" type="text" style="position:absolute; top:603px; left:173px; width:200px; height:10px;">
		<input id="dev_enc_openssl_encrypted_salt_random" class="devsite_inputs" type="text" style="position:absolute; top:603px; left:400px; width:236px; height:10px;">

		<a class="glossy_icon" style="position:absolute; top:605px; left:25px;" href="javascript:void('show tooltip')" onclick="showTipSalted()" >[?]</a>
		<a class="glossy_icon" style="position:absolute; top:580px; left:505px;" href="javascript:void('show tooltip')" onclick="showTipRandSalt()" >[?]</a>

		<!--<button class="glossy_button" style="position:absolute; top:615px; left:70px; " onclick="showTipSalted()">Salted Blurb</button>
		<button class="glossy_button" style="position:absolute; top:630px; left:400px; " onclick="showTipRandSalt()">Random Salt Blurb</button>-->

		<input id="dev_enc_openssl_encrypted_data_two_salts" class="devsite_inputs" type="text" style="position:absolute; top:676px; left:31px; width:950px;">
		<input id="dev_enc_openssl_encrypted_data_base64" class="devsite_inputs" type="text" style="position:absolute; top:752px; left:31px; width:950px;">

		<button class="glossy_button"id="dev_enc_openssl_encrypt_button" style="width:1000px; height:50px; font-size:18px;" onclick="devEncOpenSSL()">OpenSSL ENCRYPT</button>
	</div>
	<br>

	<h3 style="color:red;">OpenSSL Decrypt<a class="glossy_icon" style="" href="javascript:void('show tooltip')" onclick="showTipDecTitle()" >[?]</a></h3>
	<div style="position:relative; border:1px solid; width:1010px;">
		<img src="./svg_images/openssl_decrypt_flowchart.drawio.svg" style="width:1000px;" alt="OpenSSL Decrypt" />

		<!-- Tooltip Object for OpenSSL Encrypt--!>
		<div id="dev_dec_openssl_tooltip"style="z-index:2; display:none; position:absolute; top:100px; left:100px; background-color:lightgray; color:black; border:5px solid gold;"></div>
		<!-- Tooltip Buttons for OpenSSL Decrypt--!>
		<button class="glossy_button" style="position:absolute; top:220px; left:270px;" onclick="showTipImportKeyDec()">IMPORT KEY</button>
		<button class="glossy_button" style="position:absolute; top:415px; left:270px; " onclick="showTipDecDeriveBits()">DERIVE BITS</button>
		<button class="glossy_button" style="position:absolute; top:400px; left:850px; " onclick="showTipDecDecrypt()">DECRYPT</button>

		<input id="dev_dec_openssl_password_input" class="devsite_inputs" type="text" style="position:absolute; top:40px; left:14px; width:350px;">
		<input id="dev_dec_openssl_password_bytes" class="devsite_inputs" type="text" style="position:absolute; top:116px; left:14px; width:350px;">

		<input id="dev_dec_openssl_ciphertext_input" class="devsite_inputs" type="text" style="position:absolute; top:40px; left:460px; width:525px;">
		<input id="dev_dec_openssl_ciphertext_bytes" class="devsite_inputs" type="text" style="position:absolute; top:116px; left:460px; width:525px;">
		<input id="dev_dec_openssl_ciphertext_extracted_bytes" class="devsite_inputs" type="text" style="position:absolute; top:210px; left:465px; width:525px;">

		<!--<input id="dev_dec_openssl_derivebits_algorithm" class="devsite_inputs" type="text" value="PBKDF2" style="position:absolute; top:342px; left:14px; width:183px; height:10px;">--!>
		<input id="dev_dec_openssl_derivebits_salt" class="devsite_inputs" type="text" style="position:absolute; top:291px; left:346px; width:183px; height:10px;">
		<input id="dev_dec_openssl_derivebits_iterations" class="devsite_inputs" type="text" value="10000" style="position:absolute; top:272px; left:16px; width:183px; height:10px;">
		<!--<input id="dev_dec_openssl_derivebits_hash" class="devsite_inputs" type="text" value="SHA-256" style="position:absolute; top:444px; left:14px; width:183px; height:10px;">--!>

		<div style="background-color:cornflowerblue; font-size:14px; position:absolute; top:320px; left:20px; ">
			<fieldset >
				<legend style="color:black;">Digest Hash:</legend>
				<div>
					<input type="radio" id="SHA-256_dec" name="digest_hash_dec" value="SHA-256" checked />
					<label style="color:black;" for="SHA-256_dec">SHA-256</label>
				</div>
				<div>
					<input type="radio" id="SHA-384_dec" name="digest_hash_dec" value="SHA-384" />
					<label style="color:black;" for="SHA-384_dec">SHA-384</label>
				</div>
				<div>
					<input type="radio" id="SHA-512_dec" name="digest_hash_dec" value="SHA-512" />
					<label style="color:black;" for="SHA-512_dec">SHA-512</label>
				</div>
			</fieldset>
		</div>

		<input id="dev_dec_openssl_decrypt_algorithm" class="devsite_inputs" type="text" value="AES-CBC" style="position:absolute; top:304px; left:600px; width:128px; height:10px;">
		<textarea id="dev_dec_openssl_decrypt_iv" class="devsite_inputs" rows="2" style="position:absolute; top:363px; left:528px; width:265px; height:34px;"></textarea>
		<textarea id="dev_dec_openssl_decrypt_key" class="devsite_inputs" rows="3" style="position:absolute; top:450px; left:427px; width:350px; height:48px;"></textarea>

		<input id="dev_dec_openssl_decrypted_bytes" class="devsite_inputs" type="text" style="position:absolute; top:561px; left:17px; width:950px;">
		<input id="dev_dec_openssl_decrypted_plaintext" class="devsite_inputs" type="text" style="position:absolute; top:638px; left:17px; width:950px;">

		<button class="glossy_button"id="dev_dec_openssl_decrypt_button" style="color:red; width:1000px; height:50px; font-size:18px;" onclick="devDecOpenSSL()">OpenSSL <span style="color:red">DECRYPT</span></button>
	</div>
	<br>

	<h3 style="color:black;">Obf-1 Encrypt<a class="glossy_icon" style="" href="javascript:void('show tooltip')" onclick="showTipObf1EncTitle()" >[?]</a></h3>
	<div style="position:relative; border:1px solid; width:1010px;">
		<img src="./svg_images/obf_1_encrypt_flowchart.drawio.svg" style="width:1000px;" alt="Obf 1 Encrypt" />

		<!-- Tooltip Object for Obf1 Encrypt--!>
		<div id="dev_enc_obf1_tooltip"style="z-index:2; display:none; position:absolute; top:225px; left:375px; background-color:lightgray; color:black; border:5px solid gold;"></div>
		<!-- Tooltip Buttons for Obf1 Encrypt--!>
		<!--<button class="glossy_button" style="position:absolute; top:190px; left:320px;" onclick="showTipObf1EncShasum()">SHA SUM</button>
		<button class="glossy_button" style="position:absolute; top:480px; left:650px;" onclick="showTipObf1EncConvert()">CONVERT</button>-->
		<a class="glossy_icon" style="position:absolute; top:195px; left:340px;" href="javascript:void('show tooltip')" onclick="showTipObf1EncShasum()" >[?]</a>
		<a class="glossy_icon" style="position:absolute; top:180px; left:840px;" href="javascript:void('show tooltip')" onclick="showTipObf1EncZeroPad()" >[?]</a>
		<a class="glossy_icon" style="position:absolute; top:490px; left:660px;" href="javascript:void('show tooltip')" onclick="showTipObf1EncConvert()" >[?]</a>

		<input id="dev_enc_obf1_password_input" class="devsite_inputs" type="text" style="position:absolute; top:40px; left:37px; width:380px;">
		<input id="dev_enc_obf1_password_bytes" class="devsite_inputs" type="text" style="position:absolute; top:117px; left:37px; width:380px;">

		<input id="dev_enc_obf1_b64_input_data" class="devsite_inputs" type="text" style="position:absolute; top:40px; left:512px; width:470px;">
		<input id="dev_enc_obf1_b64_with_countstring" class="devsite_inputs" type="text" style="position:absolute; top:118px; left:512px; width:470px;">

		<input id="dev_enc_obf1_zero_padded_data" class="devsite_inputs" type="text" style="position:absolute; top:260px; left:48px; width:808px;">
		<input id="dev_enc_obf1_sha_extended_bytes" class="devsite_inputs" type="text" style="position:absolute; top:324px; left:48px; width:808px;">

		<textarea id="dev_enc_obf1_xord_data" class="devsite_inputs" rows="3" style="position:absolute; top:398px; left:20px; width:965px; height:50px;"></textarea>
		<textarea id="dev_enc_obf1_b64_output" class="devsite_inputs" rows="3" style="position:absolute; top:541px; left:20px; width:965px; height:102px;"></textarea>
		<button class="glossy_button"id="dev_enc_obf1_encrypt_button" style="color:black; width:1000px; height:50px; font-size:18px;" onclick="devEncObf1()">Obf-1 ENCRYPT</button>
	</div>
	<br>

	<h3 style="color:red;">Obf-1 Decrypt<a class="glossy_icon" style="" href="javascript:void('show tooltip')" onclick="showTipObf1DecTitle()" >[?]</a></h3>
	<div style="position:relative; border:1px solid; width:1010px;">
		<img src="./svg_images/obf_1_decrypt_flowchart.drawio.svg" style="width:1000px;" alt="Obf 1 Decrypt" />

		<!-- Tooltip Object for Obf1 DECRYPT --!>
		<div id="dev_dec_obf1_tooltip"style="z-index:2; display:none; position:absolute; top:225px; left:375px; background-color:lightgray; color:black; border:5px solid gold;"></div>
		<!-- Tooltip Buttons for Obf1 DECRYPT --!>
		<a class="glossy_icon" style="position:absolute; top:180px; left:320px;" href="javascript:void('show tooltip')" onclick="showTipObf1DecShasum()" >[?]</a>

<!--		<button class="glossy_button" style="position:absolute; top:190px; left:250px;" onclick="showTipObf1DecShasum()">SHA SUM Obf1 decrypt</button>-->
		<button class="glossy_button" style="position:absolute; top:330px; left:880px;" onclick="showTipObf1DecInverse()">INVERSE</button>

		<input id="dev_dec_obf1_password_input" class="devsite_inputs" type="text" style="position:absolute; top:40px; left:37px; width:374px;">
		<input id="dev_dec_obf1_password_bytes" class="devsite_inputs" type="text" style="position:absolute; top:117px; left:37px; width:374px;">

		<textarea id="dev_dec_obf1_b64_ciphertext" class="devsite_inputs" rows="3" style="position:absolute; top:38px; left:466px; width:526px; height:160px;"></textarea>

		<input id="dev_dec_obf1_ciphertext_bytes" class="devsite_inputs" type="text" style="position:absolute; top:256px; left:48px; width:795px;">
		<input id="dev_dec_obf1_sha_extended_bytes" class="devsite_inputs" type="text" style="position:absolute; top:319px; left:48px; width:795px;">

		<textarea id="dev_dec_obf1_xor_inversed_data" class="devsite_inputs" rows="3" style="position:absolute; top:405px; left:37px; width:960px; height:50px;"></textarea>

		<input id="dev_dec_obf1_data_with_countstring" class="devsite_inputs" type="text" style="position:absolute; top:507px; left:37px; width:950px;">
		<input id="dev_dec_obf1_data_b64_output" class="devsite_inputs" type="text" style="position:absolute; top:570px; left:37px; width:950px;">

		<button class="glossy_button"id="dev_dec_obf1_decrypt_button" style="color:red; width:1000px; height:50px; font-size:18px;" onclick="devDecObf1()">Obf-1 DECRYPT</button>
	</div>
	<br>

	<h3 style="color:black;">Obf-2 Encrypt<a class="glossy_icon" style="" href="javascript:void('show tooltip')" onclick="showTipObf2EncTitle()" >[?]</a></h3>
	<div style="position:relative; border:1px solid; width:1010px;">
		<img src="./svg_images/obf_2_encrypt_flowchart.drawio.svg" style="width:1000px;" alt="Obf 2 Encrypt" />

		<!-- Tooltip Object for Obf2 ENCRYPT --!>
		<div id="dev_enc_obf2_tooltip"style="z-index:2; display:none; position:absolute; top:225px; left:375px; background-color:lightgray; color:black; border:5px solid gold;"></div>
		<!-- Tooltip Buttons for Obf2 ENCRYPT --!>

		<a class="glossy_icon" style="position:absolute; top:180px; left:400px;" href="javascript:void('show tooltip')" onclick="showTipObf2EncShasum()" >[?]</a>

		<!--<button class="glossy_button" style="position:absolute; top:190px; left:250px;" onclick="showTipObf2EncShasum()">SHA SUM Obf2 ENCRYPT</button>-->
		<button class="glossy_button" style="position:absolute; top:400px; left:770px;" onclick="showTipObf2EncModulo()">MODULO Obf2 ENCRYPT</button>

		<input id="dev_enc_obf2_password_input" class="devsite_inputs" type="text" style="position:absolute; top:39px; left:15px; width:374px;">
		<input id="dev_enc_obf2_password_bytes" class="devsite_inputs" type="text" style="position:absolute; top:108px; left:15px; width:374px;">
		<input id="dev_enc_obf2_sha_extended_bytes" class="devsite_inputs" type="text" style="position:absolute; top:259px; left:15px; width:730px;">

		<textarea id="dev_enc_obf2_ciphertext_b64" class="devsite_inputs" rows="3" style="position:absolute; top:39px; left:443px; width:537px; height:168px;"></textarea>
		<textarea id="dev_enc_obf2_password_b64" class="devsite_inputs" rows="3" style="position:absolute; top:335px; left:15px; width:730px; height:110px;"></textarea>

		<textarea id="dev_enc_obf2_final_encrypted" class="devsite_inputs" rows="3" style="position:absolute; top:505px; left:15px; width:978px; height:140px;"></textarea>

		<button class="glossy_button"id="dev_enc_obf2_encrypt_button" style="color:black; width:1000px; height:50px; font-size:18px;" onclick="devEncObf2()">Obf-2 ENCRYPT</button>
	</div>
	<br>

	<h3 style="color:red;">Obf-2 Decrypt<a class="glossy_icon" style="" href="javascript:void('show tooltip')" onclick="showTipObf2DecTitle()" >[?]</a></h3>
	<div style="position:relative; border:1px solid; width:1010px;">
		<img src="./svg_images/obf_2_decrypt_flowchart.drawio.svg" style="width:1000px;" alt="Obf 2 Decrypt" />

		<!-- Tooltip Object for Obf2 DECRYPT --!>
		<div id="dev_dec_obf2_tooltip"style="z-index:2; display:none; position:absolute; top:225px; left:375px; background-color:lightgray; color:black; border:5px solid gold;"></div>
		<!-- Tooltip Buttons for Obf2 DECRYPT --!>


		<a class="glossy_icon" style="position:absolute; top:180px; left:400px;" href="javascript:void('show tooltip')" onclick="showTipObf2DecShasum()" >[?]</a>
		<!--<button class="glossy_button" style="position:absolute; top:190px; left:250px;" onclick="showTipObf2DecShasum()">SHA SUM Obf2 DECRYPT</button>-->
		<button class="glossy_button" style="position:absolute; top:400px; left:770px;" onclick="showTipObf2DecModulo()">MODULO Obf2 Decrypt</button>

		<input id="dev_dec_obf2_password_input" class="devsite_inputs" type="text" style="position:absolute; top:39px; left:15px; width:374px;">
		<input id="dev_dec_obf2_password_bytes" class="devsite_inputs" type="text" style="position:absolute; top:108px; left:15px; width:374px;">
		<input id="dev_dec_obf2_sha_extended_bytes" class="devsite_inputs" type="text" style="position:absolute; top:259px; left:15px; width:730px;">

		<textarea id="dev_dec_obf2_final_encrypted" class="devsite_inputs" rows="3" style="position:absolute; top:39px; left:443px; width:537px; height:168px;"></textarea>
		<textarea id="dev_dec_obf2_password_b64" class="devsite_inputs" rows="3" style="position:absolute; top:335px; left:15px; width:730px; height:110px;"></textarea>

		<textarea id="dev_dec_obf2_ciphertext_b64" class="devsite_inputs" rows="3" style="position:absolute; top:505px; left:15px; width:978px; height:140px;"></textarea>

		<button class="glossy_button"id="dev_dec_obf2_decrypt_button" style="color:red; width:1000px; height:50px; font-size:18px;" onclick="devDecObf2()">Obf-2 DECRYPT</button>
	</div>
	<br>

	<h3>Base64 Functions -- Convert int array or base64 chars into its converted form</h3>
	<div style="display:flex; flex-direction:column; ">
			<label>Input -- Length=<span id="input_length_label"></span></label>
			<textarea id="dev_b64_top" class="devsite_inputs" rows="5" style=""></textarea>
			<label>Output -- Length=<span id="output_length_label"></label>
			<textarea id="dev_b64_bot" class="devsite_inputs" rows="5" style=""></textarea>
		<button onclick="convertBase64()">Convert Base64</button>
	</div>
</div>
</body>
<script>

		//console.log("radiovalue:" + document.querySelector('input[type=radio][name=algo]:checked').value );

	// Dev Site Functions

	// Close tooltips on ESC
	window.addEventListener("keydown", function(event) {
		if (event.key === "Escape") {
			// Perform actions when Escape is pressed
				hideTipImportKeyEnc();
		}
	});   

	let site = "dev_site";
	function toggleSite(){
		if( site === "dev_site" ){
			// Switch to main_site
			document.getElementById("dev_site").style.display = "none";
			document.getElementById("main_site").style.display = "inline";
			site = "main_site";
			document.getElementById("toggle_site_button").innerHTML = "Show Dev Site";
		}else{
			// Switch to dev_site
			document.getElementById("dev_site").style.display = "inline";
			document.getElementById("main_site").style.display = "none";
			site = "dev_site";
			document.getElementById("toggle_site_button").innerHTML = "Show Main Site";
		}
	}

	function convertBase64(){
		// determine what kind of input is in top, ints or base64.
		const input = document.getElementById("dev_b64_top").value;
		let numbers = new Array();
		// If input includes any commas, we assume it's an int string.	
		if( input.includes(',') ){
			// convert ints into base64
			console.log("top input: found int string");
			const numbers = input.split(',').map(Number);
			console.log(numbers);
			const output = bytesToBase64(numbers);
			document.getElementById("dev_b64_bot").value = output;
			document.getElementById("input_length_label").innerHTML = numbers.length;
			document.getElementById("output_length_label").innerHTML = output.length;
		}else{
			// convert base64 into ints
			console.log("top input: found base64 chars");
			const output = base64ToBytes(input);
			document.getElementById("dev_b64_bot").value = output;
			document.getElementById("input_length_label").innerHTML = input.length;
			document.getElementById("output_length_label").innerHTML = output.length;
		}
	}



	//////////////////////////////////////////////////////////////
	//		Dev Site Tooltip Content & Functionality			//
	//////////////////////////////////////////////////////////////

	//OpenSSL Encrypt Tooltip Content 
	//OpenSSL Encrypt Tooltip Content 
	//OpenSSL Encrypt Tooltip Content 
	const html_openssl_enc_title= `
		<p>
			OpenSSL was chosen for the base encryption because it is widely available from the command line and its featureset includes aes-256-cbc symmetric encryption/decryption which is good enough for the US government as described in its spec document,
			<a href="https://datatracker.ietf.org/doc/html/rfc3602" target="_blank">RFC3602.</a>
			
			<br><br>
		</p>
		<button class="glossy_button" onclick="hideTipEnc()">Close</button>
	`;

	const html_openssl_enc_importkey = `
		<p>
			importKey() is a method for importing key material (e.g. a password) in a secure way that adheres to the SubtleCrypto guidelines set by the World Wide Web Consortium (the top authority/consensus for web design).<br><br>

			In this recreation of OpenSSLs command line encrypt functionality, we are using PBKDF2 as our key derivation algorithm because it offers a secure path to convert raw password key material into a cryptoKey object we can then feed into the SubtleCrypo encrypt() method which is currently the most secure way to encrypt data in a web browser. <br><br>

			The most secure way to encrypt data in a web browser is known because of the W3C Recommendation (an offical release) by the World Wide Web Consortium.<br><br>

			<a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey" target="_blank">importKey() MDN Documentation</a><br>
			<a href="https://www.w3.org/TR/webcrypto/#SubtleCrypto-method-importKey" target="_blank">importKey() W3C Specification/Documentation</a><br>
			<a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto" target="_blank">SubtleCrypto Documentation</a><br>
			<a href="https://en.wikipedia.org/wiki/World_Wide_Web_Consortium" target="_blank">W3C Wiki</a><br>
		</p>
		<button class="glossy_button" onclick="hideTipEnc()">Close</button>
	`;

	const html_openssl_enc_derivebits = `
		<p>
			deriveBits() computes raw data for both the Initialization Vector (IV) and Key required for the AES-CBC algorithm utilized in the encrypt() digest.<br><br>

			<a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/derivebits" target="_blank">deriveBits() MDN Documentation</a><br>
			<a href="https://www.w3.org/TR/webcrypto/#SubtleCrypto-method-deriveBits" target="_blank">deriveBits() W3C Specification/Documentation</a><br>
		</p>
		<button class="glossy_button" onclick="hideTipEnc()">Close</button>
	`;

	const html_openssl_enc_encrypt = `
		<p>
			encrypt() encrypts data using the specified algorithm (AES-CBC in this case) along with parameter datas like an IV.<br><br>

			<a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt" target="_blank">encrypt() MDN Documentation</a><br>
			<a href="https://www.w3.org/TR/webcrypto/#SubtleCrypto-method-encrypt" target="_blank">encrypt() W3C Specification/Documentation</a><br>
			<a href="https://www.w3.org/TR/webcrypto/#aes-cbc" target="_blank">AES-CBC W3C Specification/Documentation</a><br>
		</p>
		<button class="glossy_button" onclick="hideTipEnc()">Close</button>
	`;

	const html_openssl_enc_binary = `
		<p>
			The browser converts the binary stored arraybuffers into human readable bytes which is why binary numbers are showing up as 23, 129, 284, etc.

		</p>
		<button class="glossy_button" onclick="hideTipEnc()">Close</button>
	`;

	const html_openssl_enc_newline = `
		<p>
			In order to mirror exactly the output of the openssl command line encrypt/decrypt functions we need a newline byte that delimits the end of the linux file which is how input is treated from the command line. In other words openssl treats all command line input as a file which in linux always ends with a newline character, so we have to add it here to produce the same output and make sure command line encrypted data can be decrypted by our system and vice versa.

		</p>
		<button class="glossy_button" onclick="hideTipEnc()">Close</button>
	`;

	const html_openssl_enc_salted = `
		<p>
			OpenSSL command line encryption output includes the string literal prepend Salted__.

		</p>
		<button class="glossy_button" onclick="hideTipEnc()">Close</button>
	`;

	const html_openssl_enc_randsalt = `
		<p>
			It also includes a number 8 bytes long as a randomly generated salt which is used to run the encryption and then inserted after the Salted__ literal. This number is needed to run the decryption.

		</p>
		<button class="glossy_button" onclick="hideTipEnc()">Close</button>
	`;
	//OpenSSL Encrypt Tooltip Content 

	//OpenSSL Encrypt Tooltip Functions
	function showTipRandSalt(){
		document.getElementById("dev_enc_openssl_tooltip").innerHTML = html_openssl_enc_randsalt;
		document.getElementById("dev_enc_openssl_tooltip").style.display = "inline";
	}

	function showTipSalted(){
		document.getElementById("dev_enc_openssl_tooltip").innerHTML = html_openssl_enc_salted;
		document.getElementById("dev_enc_openssl_tooltip").style.display = "inline";
	}

	function showTipBinary(){
		document.getElementById("dev_enc_openssl_tooltip").innerHTML = html_openssl_enc_binary;
		document.getElementById("dev_enc_openssl_tooltip").style.display = "inline";
	}

	function showTipNewline(){
		document.getElementById("dev_enc_openssl_tooltip").innerHTML = html_openssl_enc_newline;
		document.getElementById("dev_enc_openssl_tooltip").style.display = "inline";
	}

	function showTipOpenSSLTitle(){
		document.getElementById("dev_enc_openssl_tooltip").innerHTML = html_openssl_enc_title;
		document.getElementById("dev_enc_openssl_tooltip").style.display = "inline";
	}

	function showTipEncDeriveBits(){
		document.getElementById("dev_enc_openssl_tooltip").innerHTML = html_openssl_enc_derivebits;
		document.getElementById("dev_enc_openssl_tooltip").style.display = "inline";
	}

	function showTipImportKeyEnc(){
		document.getElementById("dev_enc_openssl_tooltip").innerHTML = html_openssl_enc_importkey;
		document.getElementById("dev_enc_openssl_tooltip").style.display = "inline";
	}

	function showTipEncEncrypt(){
		document.getElementById("dev_enc_openssl_tooltip").innerHTML = html_openssl_enc_encrypt;
		document.getElementById("dev_enc_openssl_tooltip").style.display = "inline";
	}

	function hideTipEnc(){
		document.getElementById("dev_enc_openssl_tooltip").style.display = "none";
	}
	//OpenSSL Encrypt Tooltip Functions

	//OpenSSL Decrypt Tooltip Content
	//OpenSSL Decrypt Tooltip Content
	//OpenSSL Decrypt Tooltip Content
	const html_openssl_dec_importkey = `
		<p>
			importKey() is a method for importing key material (e.g. a password) in a secure way that adheres to the SubtleCrypto guidelines set by the World Wide Web Consortium (the top authority/consensus for web design).<br><br>

			In this recreation of OpenSSLs command line DECRYPT functionality, we are using PBKDF2 as our key derivation algorithm because it offers a secure path to convert raw password key material into a cryptoKey object we can then feed into the SubtleCrypo encrypt() method which is currently the most secure way to encrypt data in a web browser. <br><br>

			The most secure way to encrypt data in a web browser is known because of the W3C Recommendation (an offical release) by the World Wide Web Consortium.<br><br>

			<a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey" target="_blank">importKey() MDN Documentation</a><br>
			<a href="https://www.w3.org/TR/webcrypto/#SubtleCrypto-method-importKey" target="_blank">importKey() W3C Specification/Documentation</a><br>
			<a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto" target="_blank">SubtleCrypto Documentation</a><br>
			<a href="https://en.wikipedia.org/wiki/World_Wide_Web_Consortium" target="_blank">W3C Wiki</a><br>
		</p>
		<button class="glossy_button" onclick="hideTipDec()">Close</button>
	`;

	const html_openssl_dec_derivebits = `
		<p>
			deriveBits() computes raw data for both the Initialization Vector (IV) and Key required for the AES-CBC algorithm utilized in the decrypt() digest.<br><br>

			<a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/derivebits" target="_blank">deriveBits() MDN Documentation</a><br>
			<a href="https://www.w3.org/TR/webcrypto/#SubtleCrypto-method-deriveBits" target="_blank">deriveBits() W3C Specification/Documentation</a><br>
		</p>
		<button class="glossy_button" onclick="hideTipDec()">Close</button>
	`;

	const html_openssl_dec_decrypt= `
		<p>
			decrypt() decrypts data using the specified algorithm (AES-CBC in this case) along with parameter datas like an IV.<br><br>

			<a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/decrypt" target="_blank">decrypt() MDN Documentation</a><br>
			<a href="https://www.w3.org/TR/webcrypto/#SubtleCrypto-method-decrypt" target="_blank">decrypt() W3C Specification/Documentation</a><br>
			<a href="https://www.w3.org/TR/webcrypto/#aes-cbc" target="_blank">AES-CBC W3C Specification/Documentation</a><br>
		</p>
		<button class="glossy_button" onclick="hideTipDec()">Close</button>
	`;

	const html_openssl_dec_title = `
		<p>
			We chose openssl for the base encryption because it is widely available from the command line and its featureset includes aes-256-cbc symmetric encryption/decryption which is good enough for the US government as described in its spec document, RFC3602.

		</p>
		<button class="glossy_button" onclick="hideTipDec()">Close</button>
	`;
	//OpenSSL Decrypt Tooltip Content

	//OpenSSL Decrypt Tooltip Functions
	function showTipDecTitle(){
		document.getElementById("dev_dec_openssl_tooltip").innerHTML = html_openssl_dec_title
		document.getElementById("dev_dec_openssl_tooltip").style.display = "inline";
	}

	function showTipDecDeriveBits(){
		document.getElementById("dev_dec_openssl_tooltip").innerHTML = html_openssl_dec_derivebits;
		document.getElementById("dev_dec_openssl_tooltip").style.display = "inline";
	}

	function showTipImportKeyDec(){
		document.getElementById("dev_dec_openssl_tooltip").innerHTML = html_openssl_dec_importkey;
		document.getElementById("dev_dec_openssl_tooltip").style.display = "inline";
	}

	function showTipDecDecrypt(){
		document.getElementById("dev_dec_openssl_tooltip").innerHTML = html_openssl_dec_decrypt;
		document.getElementById("dev_dec_openssl_tooltip").style.display = "inline";
	}

	function hideTipDec(){
		document.getElementById("dev_dec_openssl_tooltip").style.display = "none";
	}
	//OpenSSL Decrypt Tooltip Functions

	//Obf1 Encrypt Tooltip Content
	const html_obf1_enc_shasum = `
		<p>OBF1 ENCRYPT SHASUM TOOLTIP</p>
		<img src="./svg_images/shasum_extension.svg" style="" alt="" />
		<br>
		By chaining SHA-256 hashes together we create entropy, effectively creating a pseudorandom function with an inputted password as its seed.
		<br>
		<button class="glossy_button" onclick="hideTipObf1Enc()">Close</button>
	`;

	const html_obf1_enc_zero = `
		<p>OBF1 Why Zero Pad Works</p>
		<br>
		We can use zero padding here because of the identity: X0=X
		<br>
		<button class="glossy_button" onclick="hideTipObf1Enc()">Close</button>
	`;

	const html_obf1_enc_convert = `
		<p>OBF1 ENCRYPT convert to 1000 chars b58.</p>
		<img src="./svg_images/get_1000_b58_chars.svg" style="" alt="" />
		<br>
		The blocking is a bit tricky converting bytes of size up to 256 to precisely 1000 characters of base58 characters (which have a size of 58). 256 divided by 58 = 4.413793... so we currently employ a guess and check with tapering strategy by popping bytes then converting the binary number to base 58 and checking the number of characters it converted to. If we go from 1001 characters to 999, we know we missed 1000 and enable a subroutine that converts the number from 8-bit bytes into 4-bit words which are chunks of size up to 16 giving us the precision to guarantee 1000 base 58 characters of output.

		<br>
		<button class="glossy_button" onclick="hideTipObf1Enc()">Close</button>
	`;

	const html_obf1_enc_title = `
		<p>
			Obf1 utilizes our Shasum function to produce entropy which is then XORd into the data.  We then convert the binary data from the XOR into exactly 1000 characters of base58 represented data. This turns out to be non-trivial so we implement a guess-and-check style mechanism to ensure outputs of the same length. 
		<br>
		<br>
			Our secret sauce is meant as a type of blocking that obfuscates the length of the stored data. As such our system is designed to store all data in blocks of 1000 base 58 characters. This is so that if and when an attacker accesses the stored and obfuscated data, it will be harder to decrypt. There was a time when everyone trusted Google and they deserved that trust and everything was great. That time is over. Now if youre not expecting data leaks and planning for your secure storage to be leaked at some point, are you really trying? We are attempting to help solve the problem of trusting secure systems.


		</p>
		<button class="glossy_button" onclick="hideTipObf1Enc()">Close</button>
	`;
	//Obf1 Encrypt Tooltip Content

	//Obf1 Encrypt Tooltip Functions
	function showTipObf1EncTitle(){
		document.getElementById("dev_enc_obf1_tooltip").innerHTML = html_obf1_enc_title;
		document.getElementById("dev_enc_obf1_tooltip").style.display = "inline";
	}

	function showTipObf1EncZeroPad(){
		document.getElementById("dev_enc_obf1_tooltip").innerHTML = html_obf1_enc_zero;
		document.getElementById("dev_enc_obf1_tooltip").style.display = "inline";
	}

	function showTipObf1EncShasum(){
		document.getElementById("dev_enc_obf1_tooltip").innerHTML = html_obf1_enc_shasum;
		document.getElementById("dev_enc_obf1_tooltip").style.display = "inline";
	}

	function showTipObf1EncConvert(){
		document.getElementById("dev_enc_obf1_tooltip").innerHTML = html_obf1_enc_convert;
		document.getElementById("dev_enc_obf1_tooltip").style.display = "inline";
	}

	function hideTipObf1Enc(){
		document.getElementById("dev_enc_obf1_tooltip").style.display = "none";
	}
	//Obf1 Encrypt Tooltip Functions

	//Obf1 DECRYPT Tooltip Content
	const html_obf1_dec_shasum = `
		<p>OBF1 DECRYPT SHASUM TOOLTIP</p>
		<img src="./svg_images/shasum_extension.svg" style="" alt="" />
		<br>
		By chaining SHA-256 hashes together we create entropy, effectively creating a pseudorandom function with an inputted password as its seed.
		<br>
		<button class="glossy_button" onclick="hideTipObf1Dec()">Close</button>
	`;

	const html_obf1_dec_inverse = `
		<p>OBF1 DECRYPT INVERSE</p>
		<img src="./svg_images/obf1_inverse.svg" style="" alt="" />
		<br>
		When more precision is needed for the Obf1 Encrypt binary bytes (8 bits) are converted to binary words (4 bits). When this is needed a single character is added to the left of the data. So when decrypting we run it first without stripping that leftmost character, then check if it looks like correctly decrypted data. If not we strip that single added character which will be representative of the binary word added in the encrypt step.
		<br>
		<button class="glossy_button" onclick="hideTipObf1Dec()">Close</button>
	`;

	const html_obf1_dec_title = `
		<p>
			To decrypt data from Obf1 we precisely recreate the entropy and XOR again. The decrypt works because a number XOR'd with another number twice is the same number.

		<br>
		<br>
			Our secret sauce is meant as a type of blocking that obfuscates the length of the stored data. As such our system is designed to store all data in blocks of 1000 base 58 characters. This is so that if and when an attacker accesses the stored and obfuscated data, it will be harder to decrypt. There was a time when everyone trusted Google and they deserved that trust and everything was great. That time is over. Now if youre not expecting data leaks and planning for your secure storage to be leaked at some point, are you really trying? We are attempting to help solve the problem of trusting secure systems.


		</p>
		<button class="glossy_button" onclick="hideTipObf1Dec()">Close</button>
	`;
	//Obf1 DECRYPT Tooltip Content

	//Obf1 DECRYPT Tooltip Functions
	function showTipObf1DecTitle(){
		document.getElementById("dev_dec_obf1_tooltip").innerHTML = html_obf1_dec_title;
		document.getElementById("dev_dec_obf1_tooltip").style.display = "inline";
	}

	function showTipObf1DecShasum(){
		document.getElementById("dev_dec_obf1_tooltip").innerHTML = html_obf1_dec_shasum;
		document.getElementById("dev_dec_obf1_tooltip").style.display = "inline";
	}

	function showTipObf1DecInverse(){
		document.getElementById("dev_dec_obf1_tooltip").innerHTML = html_obf1_dec_inverse;
		document.getElementById("dev_dec_obf1_tooltip").style.display = "inline";
	}


	function hideTipObf1Dec(){
		document.getElementById("dev_dec_obf1_tooltip").style.display = "none";
	}
	//Obf1 DECRYPT Tooltip Functions

	//Obf2 Encrypt Tooltip Content
	const html_obf2_enc_shasum = `
		<p>obf2 enCRYPT SHASUM TOOLTIP</p>
		<img src="./svg_images/shasum_extension.svg" style="" alt="" />
		<br>
		By chaining SHA-256 hashes together we create entropy, effectively creating a pseudorandom function with an inputted password as its seed.
		<br>
		<button class="glossy_button" onclick="hideTipObf2Enc()">Close</button>
	`;
	const html_obf2_enc_modulo = `
		<p>obf2 enCRYPT SUM AND MODULO FUNCTION</p>
		<img src="./svg_images/sum_and_modulo.svg" style="" alt="" />
		<br>
			For the second round of obfuscation we sum the index of each base58 character with entropy produced from our shasum function and then modulo the output.
		<br>
		<button class="glossy_button" onclick="hideTipObf2Enc()">Close</button>
	`;

	const html_obf2_enc_title = `
		<p>
			For the second round of obfuscation we sum the index of each base58 character with entropy produced from our shasum function and then modulo the output.
		<br>

		</p>
		<button class="glossy_button" onclick="hideTipObf2Enc()">Close</button>
	`;
	//Obf2 Encrypt Tooltip Content

	//Obf2 Encrypt Tooltip Functions
	function showTipObf2EncTitle(){
		document.getElementById("dev_enc_obf2_tooltip").innerHTML = html_obf2_enc_title;
		document.getElementById("dev_enc_obf2_tooltip").style.display = "inline";
	}

	function showTipObf2EncShasum(){
		document.getElementById("dev_enc_obf2_tooltip").innerHTML = html_obf2_enc_shasum;
		document.getElementById("dev_enc_obf2_tooltip").style.display = "inline";
	}

	function showTipObf2EncModulo(){
		document.getElementById("dev_enc_obf2_tooltip").innerHTML = html_obf2_enc_modulo;
		document.getElementById("dev_enc_obf2_tooltip").style.display = "inline";
	}

	function hideTipObf2Enc(){
		document.getElementById("dev_enc_obf2_tooltip").style.display = "none";
	}
	//Obf2 Encrypt Tooltip Functions

	//Obf2 DECRYPT Tooltip Content
	const html_obf2_dec_shasum = `
		<p>obf2 decrypt SHASUM TOOLTIP</p>
		<img src="./svg_images/shasum_extension.svg" style="" alt="" />
		<br>
		By chaining SHA-256 hashes together we create entropy, effectively creating a pseudorandom function with an inputted password as its seed.
		<br>
		<button class="glossy_button" onclick="hideTipObf2Dec()">Close</button>
	`;
	const html_obf2_dec_modulo = `
		<p>obf2 decrypt SUM AND MODULO FUNCTION</p>
		<img src="./svg_images/inverse_sum_and_mod.svg" style="" alt="" />
		<br>
		To run the inverse of our sum and mod function we can simply take the difference of the indexes and then check if the answer is negative, adding 58 in that case as we know it got modulod during the encryption step.
		<br>
		<button class="glossy_button" onclick="hideTipObf2Dec()">Close</button>
	`;

	const html_obf2_dec_title = `
		<p>
			To run the inverse of our sum and mod function we can simply take the difference of the indexes and then check if the answer is negative, adding 58 in that case as we know it got modulod during the encryption step.
		<br>
		</p>
		<button class="glossy_button" onclick="hideTipObf2Dec()">Close</button>
	`;
	//Obf2 DECRYPT Tooltip Content

	//Obf2 DECRYPT Tooltip Functions
	function showTipObf2DecTitle(){
		document.getElementById("dev_dec_obf2_tooltip").innerHTML = html_obf2_dec_title;
		document.getElementById("dev_dec_obf2_tooltip").style.display = "inline";
	}

	function showTipObf2DecShasum(){
		document.getElementById("dev_dec_obf2_tooltip").innerHTML = html_obf2_dec_shasum;
		document.getElementById("dev_dec_obf2_tooltip").style.display = "inline";
	}

	function showTipObf2DecModulo(){
		document.getElementById("dev_dec_obf2_tooltip").innerHTML = html_obf2_dec_modulo;
		document.getElementById("dev_dec_obf2_tooltip").style.display = "inline";
	}

	function hideTipObf2Dec(){
		document.getElementById("dev_dec_obf2_tooltip").style.display = "none";
	}
	//Obf2 DECRYPT Tooltip Functions


	//////////////////////////////////////////////////////////////
	//		Dev Site Hook-into-main-functionality functions		//
	//////////////////////////////////////////////////////////////

	// Rolls a random salt manually for Dev Site's encrypt OpenSSL.
	async function devManualSalt(){
		const salt = window.crypto.getRandomValues(new Uint8Array(8));
		document.getElementById("dev_enc_openssl_derivebits_salt").value = salt;
		document.getElementById("dev_enc_openssl_encrypted_salt_random").value = salt;
	}

	// Dev Site Hook function for encOpenSSL()
	async function devEncOpenSSL(){
		const input_password = document.getElementById("dev_enc_openssl_password_input").value;
		const input_plaintext = document.getElementById("dev_enc_openssl_plaintext_input").value;
		//const key_derivation_algorithm = document.querySelector('input[type=radio][name=algo]:checked').value;
		const iterations = document.getElementById("dev_enc_openssl_derivebits_iterations").value;
		//const hash = document.getElementById("dev_enc_openssl_derivebits_hash").value;
		const hash = document.querySelector('input[type=radio][name=digest_hash]:checked').value;
		const digest_algo = document.getElementById("dev_enc_openssl_encrypt_algorithm").value;

		const output_base64 = await encOpenSSL(input_plaintext, input_password, iterations, hash, digest_algo);
		document.getElementById("dev_enc_openssl_encrypted_data_base64").value = output_base64;
		// Propagate encrypt outputs to inverse decrypt function and next encrypt for now.
		document.getElementById("dev_dec_openssl_decrypt_algorithm").value = digest_algo;
		document.getElementById("dev_dec_openssl_password_input").value = input_password;
		document.getElementById("dev_dec_openssl_ciphertext_input").value = output_base64;
		document.getElementById("dev_dec_openssl_derivebits_iterations").value = iterations;
		if( hash === 'SHA-256' ){
			document.getElementById("SHA-256_dec").checked = true;
		}else if( hash === 'SHA-384' ){
			document.getElementById("SHA-384_dec").checked = true;
		}else if( hash === 'SHA-512' ){
			document.getElementById("SHA-512_dec").checked = true;
		}
		// Proopagate to next encrypt step.
		document.getElementById("dev_enc_obf1_b64_input_data").value = output_base64;
	}

	// Dev Site Hook function for decOpenSSL()
	async function devDecOpenSSL(){
		const input_password = document.getElementById("dev_dec_openssl_password_input").value;
		const input_plaintext = document.getElementById("dev_dec_openssl_ciphertext_input").value;
		//const algorithm = document.getElementById("dev_enc_openssl_derivebits_algorithm").value;
		const iterations = document.getElementById("dev_dec_openssl_derivebits_iterations").value;
		//const hash = document.getElementById("dev_dec_openssl_derivebits_hash").value;
		const hash = document.querySelector('input[type=radio][name=digest_hash_dec]:checked').value;
		const digest_algo = document.getElementById("dev_dec_openssl_decrypt_algorithm").value;

		const decrypted_plaintext = await decOpenSSL(input_plaintext, input_password, iterations, hash, digest_algo);
		document.getElementById("dev_dec_openssl_decrypted_plaintext").value = decrypted_plaintext;
	}

	// Dev Site Hook function for obf1Encrypt()
	async function devEncObf1(){
		const input_password = document.getElementById("dev_enc_obf1_password_input").value;
		const input_b64_encoded_data = document.getElementById("dev_enc_obf1_b64_input_data").value;

		const output_1000_b64 = await obf1Encrypt(input_b64_encoded_data, input_password);
		document.getElementById("dev_enc_obf1_b64_output").value = output_1000_b64;
		// Propagate encrypt outputs to decrypt.
		document.getElementById("dev_dec_obf1_password_input").value = input_password;
		document.getElementById("dev_dec_obf1_b64_ciphertext").value = output_1000_b64;
		// Proopagate to next encrypt step.
		//document.getElementById("dev_enc_obf2_password_input").value = input_password;
		document.getElementById("dev_enc_obf2_ciphertext_b64").value = output_1000_b64;
	}

	// Dev Site Hook function for obf1Decrypt()
	async function devDecObf1(){
		const input_password = document.getElementById("dev_dec_obf1_password_input").value;
		const input_b64_encoded_data = document.getElementById("dev_dec_obf1_b64_ciphertext").value;

		const output_b64 = await obf1Decrypt(input_b64_encoded_data, input_password);
		console.log("output length: " + output_b64.length);
		document.getElementById("dev_dec_obf1_data_b64_output").value = output_b64;
	}

	// Dev Site Hook function for obf1Encrypt()
	async function devEncObf2(){
		const input_password = document.getElementById("dev_enc_obf2_password_input").value;
		const input_b64_ciphertext = document.getElementById("dev_enc_obf2_ciphertext_b64").value;

		const output_final = await obf2Encrypt(input_b64_ciphertext, input_password);
		document.getElementById("dev_enc_obf2_final_encrypted").value = output_final;
		// Propagate encrypt outputs to decrypt.
		document.getElementById("dev_dec_obf2_password_input").value = input_password;
		document.getElementById("dev_dec_obf2_final_encrypted").value = output_final;
	}

	// Dev Site Hook function for obf2Decrypt()
	async function devDecObf2(){
		const input_password = document.getElementById("dev_dec_obf2_password_input").value;
		const input_final_encrypted = document.getElementById("dev_dec_obf2_final_encrypted").value;

		const output_ciphertext_b64 = await obf2Decrypt(input_final_encrypted, input_password);
		document.getElementById("dev_dec_obf2_ciphertext_b64").value = output_ciphertext_b64;
	}




	//////////////////////////////////////////////////////////////
	//		Global Flags & Page Load Function					//
	//////////////////////////////////////////////////////////////

	// Global flags. 
	let upload_flag = 'false';
	let download_flag = 'false';
	// Base 64 character map.
	const base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

	// Automatically run this function when page loads.
	window.onload = async function() {
		// Initial server online check.
		await updateOnlineStatus();

		// hide create button if already exists.
		if( document.getElementById("offline_dbase_pointer").innerHTML != "" ){
			document.getElementById("create_dbase_button").style.display = "none";
		}
	}

	// Set Title to link to Home without dropping offline dbase.
	document.getElementById("titletext").onclick = function() {
		//location.href = "https://chat.dance/obf";
		showPage('home');
	}
/*
	// later
	document.getElementById("howworks").onclick = function() {
		location.href = "/obf/how";
		// howworks();
	}
	// later
	document.getElementById("faq").onclick = function() {
		location.href = "/obf/faq";
		// faq();
	}
*/

	//////////////////////////////////////////////////////////////
	//		UI & Threadwalker Handler Functions					//
	//////////////////////////////////////////////////////////////

	// Hide all other pages, then show target page. 
	// Input: Target is the element ID of an html generated pane.
	function showPage(target){
		// Hide pass check warnings (passlock thread).
		hidePassWarnings();
		// Hide all password warnings.
		let pass_warn_elements = document.getElementsByClassName('pass_length_warn');
		for (let i = 0; i < pass_warn_elements.length; i++) {
			pass_warn_elements[i].style.display = "none";
		}

		let generated_html_pages;
		// Fill generated_html_pages array with set of objects (divs in this case) that are tagged as generated html.
		generated_html_pages = document.getElementsByClassName('gen');
		// hide all generated_html_pages
		for (let i = 0; i < generated_html_pages.length; i++) {
			generated_html_pages[i].style.display = "none";
		}
		// show target 
		document.getElementById(target).style.display = "flex";
		// focus input or textbox
		let inputs_array = document.getElementById(target).getElementsByTagName('input');
		let textareas_array = document.getElementById(target).getElementsByTagName('textarea');
		// There is only 1 input or 1 textarea per div in our setup.
		// If we found more than zero inputs in the array, focus the first and only one.
		if( inputs_array.length > 0 ){
			inputs_array[0].focus();
		}
/*
		// Otherwise, we should find 1 textarea to focus if we need to focus anything.
		 else if( textareas_array.length > 0 ){
			 textareas_array[0].focus();
		 }
*/
	}

	// Used to check password length as user flows through interface.
	// Inputs: current_div is the div presently shown to the user.
	// 		   next_div is the id of the next page in the thread which will be accessed if the password length is validated.
	// Output: Warns user and doesn't pass if length outside constraints.
	function checkPassLength(current_div, next_div){
		// Get all inputs in the active user-shown div (should only be 1).
		let input_array = document.getElementById(current_div).getElementsByTagName('input');
		if( input_array.length > 1 ){
			throw new Error('More than 1 input found in active div. This should never trigger.');
		}
		// Get the current length of the value in the password/codeword field.
		let length = input_array[0].value.length;
		// Change global password length constraints here.
		// Start at 1 to catch empty passowords/codeword. Can change later.
		if( length < 1 ){
			// Activate text informing user of error.
			//document.getElementById("password_length_warning").style.display = "inline";
			
			// Show all password warnings.
			pass_warn_elements = document.getElementsByClassName('pass_length_warn');
			for (let i = 0; i < pass_warn_elements.length; i++) {
				pass_warn_elements[i].style.display = "inline";
			}
		}else{
			// User may access next function.
			if( next_div === 'executeStore' ){
				storeExecute();
			}else if( next_div === 'executeLoad' ){
				loadExecute();
			}else{
				showPage(next_div);
			}
		}
	} //checkPassLength()

	// Clears all fields that could contain sensitive data.
	// Resets delete overlay
	function securityReset(){
		console.log("CLEARING FIELDS FOR SECURITY-- SECURITY RESET ENABLED");
		// Reset delete overlay
		deleteCheckHide('overlay_text');
		deleteCheckHide('overlay_download');
		// Clear store fields
		document.getElementById("store_data").value = '';
		document.getElementById("upload_data").value = '';
		document.getElementById("store_codeword").value = '';
		document.getElementById("store_pass_1").value = '';
		document.getElementById("store_pass_2").value = '';
		document.getElementById("store_pass_3").value = '';
		// Clear load
		document.getElementById("load_codeword").value = '';
		document.getElementById("load_pass_1").value = '';
		document.getElementById("load_pass_2").value = '';
		document.getElementById("load_pass_3").value = '';
		// Clear output display
		document.getElementById("output_display").value = '';
		// Reset download flag
		download_flag = 'false';
		// Check if we're online and inform user if we are or not.
		updateOnlineStatus();
		// Clear uploaded file
		document.getElementById("store_upload_input").value = null;
		// Clear full offline database warning. Don't think we need this because why would you ever want it off?
		//document.getElementById("full_offline_dbase_warning").style.display = "none";
	}

	// These standalone functions are required to set upload_flag in javascript.
	// User choose text input, set flag to false.
	function storeDefault(){
		//debug("Threadwalker Flow -- set upload_flag: false");
		upload_flag = 'false';
		showPage('store2');
	}

	// User choose upload, set flag to true.
	function storeUpload(){
		//debug("Threadwalker Flow -- set upload_flag: true");
		upload_flag = 'true';
		showPage('store_upload');
	}

	// On page store4, back either goes to text input or file input depending on previous user choice.
	function storeBack(){
		if( upload_flag === 'true' ){
			showPage('store_upload');
		}else{
			showPage('store3');
		}
	}

	// Store thread walk finisher.
	// async needed to handle crypto functionality
	async function storeExecute(){
		// Main Function Call
		let outcome = await deepStore();

		if( outcome == 1 ){
			//Success
			showPage('store6');
		}else if(outcome == "fullsuccess"){
			showPage('store9');
		}else if(outcome == "offline"){
			// Stored to offline dbase but not to server.
			showPage('store8');
		}else{
			// Failed to do anything.
			showPage('store7');
		}
	}//storeExecute()

	// User choose text output, set flag to false.
	function loadDefault(){
		//debug("Threadwalker Flow -- set download_flag: false");
		download_flag = 'false';
		showPage('load2');
	}

	// User choose file output, set flag to true.
	function loadDownload(){
		//debug("Threadwalker Flow -- set download_flag: true");
		download_flag = 'true';
		showPage('load3');
	}

	// On page store4, back either goes to text input or file input depending on previous user choice.
	function loadBack(){
		if( download_flag === 'true' ){
			showPage('load_choose');
		}else{
			showPage('load2');
		}
	}

	// Load thread walk finisher.
	function loadExecute(){
		// Main Function Call
		deepLoad();
		//showPage('load5');
	}

	// Show Overlay
	function deleteCheckShow(tar){
		document.getElementById(tar).style.display = "flex";
	}

	// Hide Overlay
	function deleteCheckHide(tar){
		document.getElementById(tar).style.display = "none";
	}

	// Delete thread walk finisher.
	async function deleteExecute(){
		// Main Function Call
		const outcome = await deepDelete();
		
		if( outcome == "success" ){	
			showPage('delete5');
		}else if(outcome == "failed server"){ 
			showPage('delete6');
		}else if(outcome == "failed all"){ 
			showPage('delete7');
		}else{
			console.log("error: delete inform failed.");
			showPage('delete7');
		}

		// Also delete user inputted data.
		securityReset();
	}

	// Catch File Ingest
	// listener is placed inline of the html
	async function catchUpload(event){
		const file = event.target.files[0];
		const reader = new FileReader();
		reader.readAsArrayBuffer(file);

		reader.onload = function(e){
			let buffer = e.target.result;
//console.log("init buffer size: " + buffer.length);
//console.log("init buffer: " + buffer);
			const buffer_uint8a = new Uint8Array(buffer);
//console.log("new buffer size: " + buffer_uint8a.length);
//console.log("new buffer: " + buffer_uint8a);
			let filedata = bytesToBase64(buffer_uint8a);
			//let filedata = bytesToBase64(buffer_uint8a);
//console.log("filedata size (calculated bytes): " + filedata.length );
//console.log("filedata: " + filedata);
			//debug("Data Flow catchUpload() -- uploaded file content:");
			//debug(filedata);
			// Input Data Length Check
			//if( checkInputLength(filedata) ){
			if( checkInputLength(buffer) ){
				// Data Length within parameters
				document.getElementById("upload_data").value = filedata;
				document.querySelectorAll(".store.upload").forEach(a=>a.style.display = "none");
				// skip data and pass1 input screens
				document.querySelectorAll(".store.four").forEach(a=>a.style.display = "flex");
				// for back functionality, we need a button to continue
				document.getElementById("store_upload_continue").style.display = "inline";
				document.getElementById("store_upload_input").style.border = "";
				// add red warning text
				document.getElementById("store_upload_warning").style.display = "none";
			}else{
				// Data Length too long! Show Warning.
				// hide continue button
				document.getElementById("store_upload_continue").style.display = "none";
				// make border red
				document.getElementById("store_upload_input").style.border = "thick solid red";
				// add red warning text
				document.getElementById("store_upload_warning").style.display = "inline";
			}
		}
	}

	// Called on change of text area, checks length of that text area and shows warning if input data too long.
	function checkTextInputLength(input_id){
		//let input = document.getElementById("store_data").value;
		let input = document.getElementById(input_id).value;
		if( checkInputLength(input) ){
			// Length OK, turn off warning
			document.getElementById("text_input_warning").style.display = "none";
			// display button
			document.getElementById("text_input_continue").style.display = "inline";
		}else{
			// remove button
			document.getElementById("text_input_continue").style.display = "none";
			// Length NOT OK, turn ON warning
			document.getElementById("text_input_warning").style.display = "inline";
		}
	}
/*
	// Automatically run this function when page loads.
	window.onload = async function() {
		// Initial server online check.
		await updateOnlineStatus();

		// hide create button if already exists.
		if( document.getElementById("offline_dbase_pointer").innerHTML != "" ){
			document.getElementById("create_dbase_button").style.display = "none";
		}
	}
*/

	//////////////////////////////////////////////////////////////
	//				Offline Database Functions					//
	//////////////////////////////////////////////////////////////

	// Gather passwords to access existing records and gather them into a new offline dbase.
	function createNewOfflineDBaseThread(){
		createNewOfflineDBase();
		// activate some html
		showPage("create_new_offline_dbase_div");
	}

	// Delete the entire offline dbase.
	function deleteOfflineDBase(){
		console.log("DELETING offline dbase...");
		document.getElementById("offline_dbase_pointer").innerHTML = "";
		document.getElementById("offline_dbase").innerHTML = "";
	}

	// Leave the Create New Offline Database page and KEEP the new offline dbase.
	function doneNewOfflineDBase(){
		// hide create button while dbase exists
		document.getElementById("create_dbase_button").style.display = "none";
		document.getElementById("status_label").style.display = "none";
		showPage("home");
	}

	// Leave the Create New Offline Database page and DELETE the new offline dbase.
	function cancelNewOfflineDBase(){
		// There shouldn't be an offline dbase but if there is, delete it.
		deleteOfflineDBase();
		document.getElementById("status_label").style.display = "none";
		// hide create button while dbase exists
		//document.getElementById("create_dbase_button").style.display = "none";
		showPage("home");
	}

	// Transform Cancel button into Done button. This function called once there is valid data in the offline dbase.
	function hideCancelShowDone(){
		document.getElementById("new_offline_dbase_cancel_button").style.display = "none";
		document.getElementById("new_offline_dbase_completed_button").style.display = "inline";
	}

	// Handles Create New Offline DBase UI while user is adding records.
	// Takes the inputted passwords/codeword and queries the server for existing records in an attempt to add them to the offline dbase.
	async function accessDataForOfflineDBaseCreation(){
		// Don't need password 1 which is used for command line encryption or its browser backup.
		const codeword = document.getElementById("gather_codeword").value;
		const pass_2 = document.getElementById("gather_password2").value;
		const pass_3 = document.getElementById("gather_password3").value;
		document.getElementById("gather_codeword").value = "";
		document.getElementById("gather_password2").value = "";
		document.getElementById("gather_password3").value = "";
		// Re-focus on first input field.
		document.getElementById("gather_codeword").focus();

		const fp_hex = await computeFingerprint(codeword, pass_2, pass_3);
		// Fingerprint length check.
		if( fp_hex.length != 64 ){
			throw new Error('Fingerprint length INVALID!');
		}

		console.log("offline dbase creation: Querying server...");
		const sr_load = await serverLoad(fp_hex);
		console.log("offline dbase creation: Access Server Response, data: " + sr_load.data);
		// Null check needed so error handling + server communication works as expected.
		if(sr_load != null){
			if( sr_load.data == "" ){
				// Inform user that access failed, continue on the same page.
				document.getElementById("status_label").innerHTML = "FAILED TO ACCESS DATA FROM SERVER";
				document.getElementById("status_label").style.display = "flex";
			}else{
				console.log("DATA ACCESSED FROM SERVER, ATTEMPTING TO ADD IT TO OFFLINE DATABASE.");
				// Add a record to the new offline dbase.
				const result = storeSingleRecordToOfflineDBase(fp_hex, sr_load.data);
				if( result == "success" ){
					// Transform Cancel button into Done button.
					hideCancelShowDone();
					document.getElementById("status_label").innerHTML = "SUCCESSFULLY ADDDED DATA TO OFFLINE DATABASE";
					document.getElementById("status_label").style.display = "flex";
				}else{
					document.getElementById("status_label").innerHTML = "FAILED TO ADD DATA TO OFFLINE DATABASE";
					document.getElementById("status_label").style.display = "flex";
				}
			}
		}	
	}
	// Fill a new offline dbase with random fingerprints and datas.
	function createNewOfflineDBase(){
		// Inform user of re-foll if button clicked while already in new offline dbase creation UI.
		document.getElementById("status_label").innerHTML = "NEW OFFLINE DATABASE INITIALIZED.";
		document.getElementById("status_label").style.display = "inline";

		console.log("creating new offline dbase...");
		// Init pointer.
		const pointer = randomInt(0,90);
		console.log("pointer: " + pointer);
		// Set pointer to data location that will persist if the user decides to download a standalone.html.
		document.getElementById("offline_dbase_pointer").innerHTML = pointer;
		let offline_dbase = "";			// Init string.
		const number_of_records = 100; 	// database size
		// Fill the new offline dbase with random data.
		for(let i=0; i < number_of_records; i++ ){
			offline_dbase += getRandFingerprint();	// Add a new random fingerprint.
			offline_dbase += getRandData();			// Add a set of random data.
		}
		//return offline_dbase;
		document.getElementById("offline_dbase").innerHTML = offline_dbase;
	}

	// Get 64 hex chars for a random fingerprint.
	function getRandFingerprint(){
		let new_fingerprint = "";
		for(let i=0; i < 64; i++){
			// creates an 8 bit number: 0-64
			// get a random number 0-16
			const random_value = Math.floor( window.crypto.getRandomValues(new Uint8Array(1)) / 16);
			//console.log("random buffer: " + random_value);
			const random_hex_char = random_value.toString(16);
			//console.log("random hex char: ~" + random_hex_char + "~");
			new_fingerprint += random_hex_char;
		}
		//console.log("completed random fingerprint: " + new_fingerprint);
		return new_fingerprint;
	}

	// Get 1000 b64 chars for a random data.
	function getRandData(){
		// We're going to fill this string with random base64 chars.
		let new_data = "";
		// Generate 1000 random b64 chars.
		for(let i=0; i < 1000; i++){
			const random_b64_int = randomInt(0,63);
			//console.log("random b64 value: " + random_b64_int);
			const random_b64_char = base64map.charAt(random_b64_int);
			//console.log("random b64 char: " + random_b64_char);
			new_data += random_b64_char;
		}
		//console.log("completed random data: " + new_data);
		return new_data;
	}

	// Check if a fingerprint looks valid.
	function checkFingerprintIsValid(fingerprint){
		// false if any non-hex chars or not 64 long.
		const regex = /^[0-9a-f]{64}$/;
		if( regex.test(fingerprint) ){
			return 1;
		}else{
			return 0;
		}
	}

	// Make sure input is exactly 1000 chars of base64 data.
	function checkDataIsValid(data){
		const regex = /^[a-zA-Z0-9\+\/\=]{1000}$/;
		if( regex.test(data) ){
			return 1;
		}else{
			return 0;
		}
	}

	// Input is a record that will be stored in the offline dbase at current pointer location. Pointer is then incremented.
	function storeSingleRecordToOfflineDBase(fp_hex, encrypted_data){
		// Check that both fingerprint and data are valid.
		if( !checkFingerprintIsValid(fp_hex) ){
			throw new Error('Attempt to store to offline dbase failed! FINGERPRINT is invalid.');
		}else{ console.log("FINGERPRINT IS VALID!");}
		if( !checkDataIsValid(encrypted_data) ){
			throw new Error('Attempt to store to offline dbase failed! DATA is invalid.');
		}else{ console.log("DATA IS VALID!");}
		// Input new fingerprint and data at pointer location.
		let pointer = document.getElementById("offline_dbase_pointer").innerHTML;
		console.log("pulled pointer from DOM object: " + pointer);
		// Check if offline database is full.
		if( pointer >= 99 ){
			// Offline Database is full. Inform user.
			document.getElementById("full_offline_dbase_warning").style.display = "inline";
			return "full";	//End function.
		}

		// Load offline database.
		const offline_dbase = document.getElementById("offline_dbase").innerHTML;

		// First check if record already exists in offline dbase.
		const regex = new RegExp(String.raw`${fp_hex}`, "g");
		console.log("regex used for storeSingleRecordToOfflineDBase: " + regex);

		// -1 returned on miss.
		const search_outcome = offline_dbase.search(regex);
		console.log("outcome: " + search_outcome);

		// We know there is an existing record if we hit.
		if(search_outcome > -1){
			console.log("found fingerprint in offline dbase");
			// replace data following fingerprint with input encrypted_data
			const fp_offset = search_outcome + 64;
			const offset_end = search_outcome + 1064;
			const replacement_offline_dbase = offline_dbase.substring(0, fp_offset) + encrypted_data + offline_dbase.substring(offset_end);
			// Now save modified offline dbase back to html.
			document.getElementById("offline_dbase").innerHTML = replacement_offline_dbase;
			return "success";
		}

		// Input new fingerprint and data at pointer location.
		//let pointer = document.getElementById("offline_dbase_pointer").innerHTML;
		//console.log("pulled pointer from DOM object: " + pointer);
		const pointer_offset = pointer * 1064;
		console.log("calculated offset: " + pointer_offset);
		const pointer_end = pointer_offset + 1064;

		// Replacing randomly generated data.
		// If we've done our job, everything should line up.
		const replacement_offline_dbase = offline_dbase.substring(0, pointer_offset) + fp_hex + encrypted_data + offline_dbase.substring(pointer_end);
		// Now save modified offline dbase back to html so it will persist when saving a standalone.html.
		document.getElementById("offline_dbase").innerHTML = replacement_offline_dbase;
	
		// Increment pointer.	
		pointer++;
		document.getElementById("offline_dbase_pointer").innerHTML = pointer;
		console.log("Incremented pointer after dbase saved: " + document.getElementById("offline_dbase_pointer").innerHTML);

		// Check if we hit last save locaation.
		// If we did, inform user we have reached end of data and they will need to use a new offline database.
		if( pointer >= 99 ){ // I think use 99 here because the randomInt() function states the input range is inclusive.
			// Offline Database is now full. Inform user.
			document.getElementById("full_offline_dbase_warning").style.display = "inline";
		}

		//Check Load, return success or failure.
		const load_check_data = attemptLoadOfflineDBase(fp_hex);
		if( load_check_data === encrypted_data ){
			return "success";
		}else{
			return "fail";
		}
	}

	// Load data at fingerprint. 
	// If it exists return data, 
	// if it does not exist return the string "miss".
	function attemptLoadOfflineDBase(fp_hex){
		// Load offline database.
		const offline_dbase = document.getElementById("offline_dbase").innerHTML;
		// Search for fingerprint in offline dbase using regex.
		const regex = new RegExp(String.raw`${fp_hex}`, "g");
		console.log("regex used for attemptLoadOfflineDBase: " + regex);
		// -1 returned on miss.
		const search_outcome = offline_dbase.search(regex);
		console.log("outcome: " + search_outcome);
		// search_outcome will be the index of the beginning of the matched fingerprint.
		if(search_outcome > -1){
			// Move to the end of the fingerprint.
			const fp_offset = search_outcome + 64;
			// Move to the end of the data.
			const data_offset = fp_offset + 1000;
			// Get the data between fp_offset and data_offset, should be 1000 chars.
			const loaded_data = offline_dbase.substring(fp_offset, data_offset);
			return loaded_data;
		}else{
			return "miss";
		}
	}

	// Delete record from offline dbase at fingerprint location.
	// then decrement pointer if found.
	function deleteSingleRecordOfflineDBase(fp_hex){
		// Check that fingerprint is valid.
		if( !checkFingerprintIsValid(fp_hex) ){
			throw new Error('Attempt to DELETE single record in offline dbase failed! FINGERPRINT is invalid.');
		}else{ console.log("FINGERPRINT IS VALID!");}

		// Load offline database.
		const offline_dbase = document.getElementById("offline_dbase").innerHTML;

		// Find record in offline dbase if it exists.
		const regex = new RegExp(String.raw`${fp_hex}`, "g");
		console.log("regex used for deleteSingleRecordOfflineDBase: " + regex);

		// -1 returned on miss.
		const search_outcome = offline_dbase.search(regex);
		console.log("regex search outcome for delete call: " + search_outcome);

		// If the record exists, delete the fingerprint and data at search_outcome location.
		if(search_outcome > -1){
			console.log("found fingerprint in offline dbase");
			// Remove all data from search_outcome to offset end, which should be the fingerprint and data of the found record.
			const offset_end = search_outcome + 1064;
			const replacement_offline_dbase = offline_dbase.substring(0, search_outcome) + offline_dbase.substring(offset_end);
			// Now save modified offline dbase back to html.
			document.getElementById("offline_dbase").innerHTML = replacement_offline_dbase;
			// We've found and deleted the data, now decrement pointer.
			console.log("pointer BEFORE delete: " + document.getElementById("offline_dbase_pointer").innerHTML);
			let pointer = document.getElementById("offline_dbase_pointer").innerHTML;
			// decrement pointer
			pointer--;
			// Check if offline database is no longer full.
			if( pointer < 99 ){
				// Offline Database is full. Inform user.
				document.getElementById("full_offline_dbase_warning").style.display = "none";
			}
			// Save pointer back to persistent storage.
			document.getElementById("offline_dbase_pointer").innerHTML = pointer;
			console.log("Decremented pointer AFTER delete: " + document.getElementById("offline_dbase_pointer").innerHTML);
			return "success";
		}else{
			// We didn't find it! return fail.
			return "fail";
		}
	}

	// Moving this code to a function aviods some nested if blocks.
	// This function tries to store to offline dbase and returns the outcome.
	async function handleOfflineDBaseStore(fp_hex, encrypted_data){
		console.log("Attempting to store to offline dbase...");
		const outcome = storeSingleRecordToOfflineDBase(fp_hex, encrypted_data);
		if( outcome === "full" ){
			return outcome;			
		}else if( outcome != "success" ){
			throw new Error('ERROR STORING TO OFFLINE DATABASE!');
			return "error";
		}
		// Run the Burst Store.
		const burst_save_response = await sendOfflineDBaseToServer();
		if( burst_save_response != null){
			console.log("burst response: " + burst_save_response.response);
			// Not sure yet how I want to check that it worked.
			if( burst_save_response.response === "success"){
				return 1;
			}else{
				return 0;
				// Maybe delete the record if it fails to load correctly?
			}
		}else{
			// We've successfully stored to offline dbase BUT failed to store because we're offline.
			return "offline";
		}
	}


	//////////////////////////////////////////////////////////////
	//					Core Functions						    //
	//////////////////////////////////////////////////////////////

	// Main Store Function Handler
	// Takes the inputs gathered from the user, processes them, communicates with the server, and produces output for the user as needed.
	// Inputs: Plaintext held in inputs hidden from the user until all data is ready for the server query.
	// Output: Functionality.
/*
	async function deepStore(){
		// Get save data from user.
		const plaintext = document.getElementById("store_data").value;
		// Get code/passwords from user.
		const codeword = document.getElementById("store_codeword").value;
		const pass_1 = document.getElementById("store_pass_1").value;
		const pass_2 = document.getElementById("store_pass_2").value;
		const pass_3 = document.getElementById("store_pass_3").value;
	*/
	async function deepStore( plaintext, cleartextSet ){
		const uploadtext = document.getElementById("upload_data").value;
		const pass_1 = cleartextSet[0];
		const pass_2 = cleartextSet[1];
		const pass_3 = cleartextSet[2];
		const codeword = cleartextSet[3];

		console.log("cleartext: " + plaintext);
		console.log("pass1: " + pass_1);
		console.log("pass2: " + pass_2);
		console.log("pass3: " + pass_3);
		console.log("codeword: " + codeword);
		
		let encrypted_data;
		// Use flag set by storeUpload() to determine which enc stack to use.
		if( upload_flag == 'true' ){
			// Grab upload_flag value for server database flag.
			// Double Encrypt
			encrypted_data = await encryptDouble(uploadtext, pass_2, pass_3);
			// reset flag once it is used
			upload_flag = 'false';
		}else{
			// Triple Encrypt
			encrypted_data = await encryptStack(plaintext, pass_1, pass_2, pass_3);
		}

		const fp_hex = await computeFingerprint(codeword, pass_2, pass_3);
		// fingerprint length check
		if( fp_hex.length != 64 ){
			throw new Error('Fingerprint length INVALID!');
		}

		let offline_dbase_store_outcome;
		if( document.getElementById("offline_dbase_pointer").innerHTML != "" ){
			offline_dbase_store_outcome = await handleOfflineDBaseStore(fp_hex, encrypted_data);
			// Return from deepStore() unless the offline dbase is full, in which case store that single normally by not returning from deepStore.
			if( offline_dbase_store_outcome != "full" ){
				return offline_dbase_store_outcome;
			}
		}

		// Attempt to store a record to the server.
		const server_response = await serverStore(fp_hex, encrypted_data);
		if( server_response != null){
			sr_store_result = server_response.response;
			//debug("Server Handling - deepStore() -- Response from STORE: " + "~" + sr_store_result + "~");
			// Store returned 0 (fail).
			if( Number(sr_store_result) != 1){
				throw new Error('STORE ERROR!');
			}
		}else{
			return;
		}

		// Check Load
		// return of 0 means fingerprint form check fails
		// return of empty means fingerprint returned nothing
		const sr_load = await serverLoad(fp_hex);
		//debug("Server Handling - deepStore() -- Response from LOAD (store final check): " + "~" + sr_load.data + "~");

		// Report Results
		if(sr_load != null){ // Looks like we have to use this nested loop for null check or code will break.
			if(encrypted_data  === sr_load.data && offline_dbase_store_outcome === "full"){
				return "fullsuccess";
			}else if(encrypted_data  === sr_load.data){
				return 1;
			}else{
				return 0;
				// Maybe delete the record if it fails to load correctly?
			}
		}else{
			return 0;
		}
	}//deepStore()

	// Main Access Function Handler
	// Takes the inputs gathered from the user, processes them, communicates with the server, and produces output for the user as needed.
	// Inputs: plaintext held in inputs hidden from the user until all data is ready for the server query.
	// Output: functionality.
	async function deepLoad(){
		// Get code/passwords from user.
		const codeword = document.getElementById("load_codeword").value;
		const pass_1 = document.getElementById("load_pass_1").value;
		const pass_2 = document.getElementById("load_pass_2").value;
		const pass_3 = document.getElementById("load_pass_3").value;

		//debug("Attempting Server LOAD - deepLoad()"); 
		//debug("Server Handling - deepLoad() -- Codeword: " + codeword); 
		//debug("Server Handling - deepLoad() -- Password 1: " + pass_1); 
		//debug("Server Handling - deepLoad() -- Password 2: " + pass_2); 
		//debug("Server Handling - deepLoad() -- Password 3: " + pass_3); 

		const fp_hex = await computeFingerprint(codeword, pass_2, pass_3);
		// fingerprint length check
		if( fp_hex.length != 64 ){
			throw new Error('Fingerprint length INVALID!');
		}

		// First check offline database for record.
		const data_from_offline_dbase = attemptLoadOfflineDBase(fp_hex);
		if( data_from_offline_dbase != "miss" ){
			// Decrypt Block
			await decryptAndShowUser(data_from_offline_dbase);
			return;
		}

		console.log("Querying server...");

		// Load from server
		//debug("Server Handling - deepLoad() -- Attempting Load with fingerprint: " + fp_hex);
		const sr_load = await serverLoad(fp_hex);
		if(sr_load == null){
			showPage('failed_to_access');
			return;
		}else{
			if( sr_load.data == "" ){
				showPage('failed_to_access');
				return;
			}
		}

		// Decrypt Block
		await decryptAndShowUser(sr_load.data);
	}//deepLoad()

	// Decrypts input encrypted_data and decides whether to show the user in plaintext or give them a file to decrypt.
	async function decryptAndShowUser(encrypted_data){
		console.log("decryptAndShowUser entered.");
		const pass_1 = document.getElementById("load_pass_1").value;
		const pass_2 = document.getElementById("load_pass_2").value;
		const pass_3 = document.getElementById("load_pass_3").value;

		// Your Encryption
		if( download_flag == 'true' ){
			console.log("File encryption - your encryption.");
			showPage('load_download');
			// Double Decrypt
			decrypted_data = await decryptDouble(encrypted_data, pass_2, pass_3);
			const bytes = base64ToBytes( decrypted_data );
			// Produce file for user to decrypt.
			let blob = new Blob([bytes]);
			let a = document.createElement('a');
			a.href = window.URL.createObjectURL(blob);
			a.download = 'secretword_output_file.txt';
			a.click();
		}else{ // Our Encryption
			console.log("our encryption.");
			showPage('load_text');
			// Triple Decrypt
			const decrypted = await decryptStack(encrypted_data , pass_1, pass_2, pass_3);
			console.log("decrypted: " + decrypted);
			// Report Results 
			document.getElementById("output_display").value = decrypted;
		}
	}

	// Main Delete Function Handler
	// Takes the inputs gathered from the user, processes them, communicates with the server, and produces output for the user as needed.
	// Inputs: plaintext held in inputs hidden from the user until all data is ready for the server query.
	// Output: functionality.
	async function deepDelete(){
		// Get code/passwords from user.
		// For Delete, we will now be in the Access thread and should be able to use already entered values.
		const codeword = document.getElementById("load_codeword").value;
		const pass_1 = document.getElementById("load_pass_1").value;
		const pass_2 = document.getElementById("load_pass_2").value;
		const pass_3 = document.getElementById("load_pass_3").value;
		//debug("Attempting Server DELETE - deepDelete()"); 
		//debug("Server Handling - deepDelete() -- Codeword: " + codeword); 
		//debug("Server Handling - deepDelete() -- Password 1: " + pass_1); 
		//debug("Server Handling - deepDelete() -- Password 2: " + pass_2); 
		//debug("Server Handling - deepDelete() -- Password 3: " + pass_3); 

		const fp_hex = await computeFingerprint(codeword, pass_2, pass_3);
		////debug("fingerprint hex: " + fp_hex);
		////debug("fingerprint length: " + fp_hex.length);
		// fingerprint length check
		if( fp_hex.length != 64 ){
			throw new Error('Fingerprint length INVALID!');
		}

		let offline_dbase_delete_success = '';
		// If there's an offline dbase, also try to delete it there.
		if( document.getElementById("offline_dbase_pointer").innerHTML != "" ){
			////debug("deepDelete() -- Attempting Offline Database Delete with fingerprint: " + fp_hex);
			console.log("deepDelete() -- Attempting Offline Database Delete with fingerprint: " + fp_hex);
			const outcome = await deleteSingleRecordOfflineDBase(fp_hex);
			if( outcome != "success" ){
					console.log("failed offline dbase");
				return "failed offline dbase";
			}else{
				offline_dbase_delete_success = '1';
			}
		}

		// Load from server
		//debug("Server Handling - deepDelete() -- Attempting Delete with fingerprint: " + fp_hex);
		const sr_delete = await serverDelete(fp_hex);
		//return sr_delete.response;
		if( sr_delete != null){
			console.log("what is delete success response? 1?: " + "~" + sr_delete.response + "~");
			if( sr_delete.response == '1' ){
				console.log("success");
				return "success";
			}
		}

		if( offline_dbase_deleted ){
				console.log("failed server");
			return "failed server";
		}else{
				console.log("failed all");
			return "failed all";
		}
	}//deepDelete()



/*
	async function initiatePasslock(userPassInputId){
		//Store user's password in javascript and delete it from html.
		const userPass = extractUserPass(userPassInputId);
		
		// Reset global variables.	
		resetPasslock();
		// Generate passlock key value pair.
		const passlock = await generatePasslock();
		const encrypted_password = await passlockEncrypt(userPass, passlock);
		passlocked_passwords.push( encrypted_password );
	}

	async function continuePasslock(userPassInputId){
		const userPass = extractUserPass(userPassInputId);
		
		const passlock = getPasslock();
		const encrypted_password = await passlockEncrypt(userPass, passlock);
		passlocked_passwords.push( encrypted_password );
		console.log("passlock password array:");
		console.log("test inline" + passlocked_passwords);
		console.log(passlocked_passwords);
	}
*/

	function showPassWarnings(){
		// Show all password warnings.
		pass_check_elements = document.getElementsByClassName('pass_check_warning');
		for (let i = 0; i < pass_check_elements.length; i++) {
			pass_check_elements[i].style.display = "inline";
		}
	}

	function hidePassWarnings(){
		// Show all password warnings.
		pass_check_elements = document.getElementsByClassName('pass_check_warning');
		for (let i = 0; i < pass_check_elements.length; i++) {
			pass_check_elements[i].style.display = "none";
		}
	}
	//////////////////////////////////////////////////////////////
	//			Passlock Functions							    //
	//////////////////////////////////////////////////////////////

	// Global browser_id variable to be used for accessing passlock, 
	// the random password we're using to encrypt data as user moves through interface.
	let browser_id_global;
	let passlocked_passwords; //Array to hold passlocked passwords.
	//Reset passlock global variables
	function resetPasslock(){
		browser_id_global = null;
		passlocked_passwords = new Array;
		console.log("passlock reset.");
	}

	//Function that extracts user password from html and deletes it from the html source.
	function extractUserPass(userPassInputId){
		const userPass = document.getElementById(userPassInputId).value;
		document.getElementById(userPassInputId).value = ""; //delete password from html
		return userPass;
	}

	function weTimedOut(){
		console.log("weTimedOut() ran successfully.");
		// Delete client held data. Should be able to just check for null to see if we're timed out.
		//resetPasslock();
		// Tell server to delete passlock record.
		//serverDeletePasslock();
	}

	// Generate a browser_id, passlock and save them to server as a key-value pair.
	async function generatePasslock(){
		// Reset global variables.	
		resetPasslock();
		// Generate and set browser_id;
		browser_id_global = self.crypto.randomUUID();
		// Gen new passlock;
		const passlock = self.crypto.randomUUID();
		// Send to server.
		const returned = await serverSetPasslock(browser_id_global, passlock);
		console.log(returned);
		console.log("new browser_id: " + browser_id_global);
		console.log("new passlock: " + passlock);
		// Set timeout timer.
		setTimeout(() => {
			console.log("Timeout timer expired!");
			weTimedOut();
		}, 1000); // One Second.
		return passlock;
	}

	// Can be removed if generatePasslock();passlockAdd() is used instead
	// That means we do 1 more server call. Because O() notation complexity I think 1 call in 8 is taught to mean nothing in context.
	// ==> By saving 1 server call in many, we use an additional function.
	//	Also we use crypto data in a different way, giving more changes for errors.
	//	Also we're now managing 3 functionss that do 2 things in different ways that isn't immediately clear instead of 2 functions that do specific things.
	//
	// I guess we need to use it tho as about half the time the server didn't have the passlock in time for the retreival.
	async function initiatePasslock(userPassInputId){
		//Store user's password in javascript and delete it from html.
		const userPass = extractUserPass(userPassInputId);
		// Generate passlock key value pair.
		const passlock = await generatePasslock();
		const encryptedPassword = await encOpenSSL(userPass, passlock);
		passlocked_passwords.push( encryptedPassword );
	}

	// Add encrypted user password to passlock array.
	async function passlockAdd(userPassInputId){
		// Can add length check here
		const userPass = extractUserPass(userPassInputId);
		const encryptedPassword = await passlockEncrypt(userPass);
		passlocked_passwords.push( encryptedPassword );
	}

	// Checks existing encrypted pass at index vs reiteration step encrypted value.
	async function checkPasslock(index, userPassInputId, thisPageId, nextPageId){
		const userPass = extractUserPass(userPassInputId);
		const encryptedPassword = await passlockEncrypt(userPass);
		if( passlocked_passwords[index] === encryptedPassword){
			// Password re-iterated successfully, continue to next page.
			showPage(nextPageId);
		}else{
			showPassWarnings();
			// Re-iterated password doesn't match original.
			throw Error("Passwords are different!");
			// Failed to re-iterate, Stay on this page.
		}
	}

	// Return passlock for encrypt/decrypt functions if not timed out.
	async function getPasslock(){
		// Check for timeout
		if( browser_id_global === null ){
			throw Error("Passlock is timed out!");
		}
		// Return passlock json object if not timed out.
		const passlockJsonObject = await serverGetPasslock(browser_id_global);
		console.log("browser id: " + browser_id_global);
		console.log(passlockJsonObject);
		// Return data from json object.
		return passlockJsonObject.passlock;
	}

	// Use previously generated passlock to encrypt input.
	// Returns encrypted password.
	// Should check for timeout and return error if so.
	async function passlockEncrypt(cleartextPassword){
		const passlock = await getPasslock();
		// I think await is needed here because need a variable before returning?
		const encryptedPassword = await encOpenSSL(cleartextPassword, passlock);
		console.log("retrieved passlock: " + passlock);
		console.log("cleartextPassword: " + cleartextPassword);
		console.log("encryptedPassword: " + encryptedPassword);
		return encryptedPassword;
	}

	// Use previously generated passlock to decrypt input.
	// Returns decrypted password.
	//
	// Unused function.
	async function passlockDecrypt(encryptedPassword){
		const passlock = await getPasslock();
		const cleartextPassword = await decOpenSSL(encryptedPassword, passlock);
		return cleartextPassword;
	}

	// Decrypt passlocked password set and return cleartext set.
	async function passlockDecryptSet(){
		const passlock = await getPasslock();
		let cleartextPassword;
		let cleartextSet = new Array;
		for(let i=0; i < 4; i++ ){
			cleartextPassword = await decOpenSSL(passlocked_passwords[0], passlock);
			cleartextSet.push(cleartextPassword);
		}
		console.log("retrieved passlock: " + passlock);
		console.log("cleartext Password Set: " + cleartextSet);
		console.log("encrypted Password Set: " + passlocked_passwords);
		return cleartextSet;
	}

	async function commitDataToServer(cleartextDataInputId){
		// Get user data, clear from html.
		const cleartextData = extractUserPass(cleartextDataInputId);
		console.log("cleartext data: " + cleartextData);
		// Get decrypted passwords
		let cleartextSet = await passlockDecryptSet();
console.log(cleartextSet);
		// Store to server.
		const outcome = await deepStore(cleartextData, cleartextSet);
		console.log("deepStore outcome: " + outcome);
	}

	// Decrypt password stored in target object.
	// 
	async function showPassword( object_holding_password_to_show ){

	}

	//////////////////////////////////////////////////////////////
	//			Server Communication Functions				    //
	//////////////////////////////////////////////////////////////

	// Check if we're online or not and inform user.
	async function updateOnlineStatus(){
		document.getElementById("offline_label").innerHTML = "ONLINE STATUS PENDING...";
		// Check if we're online
		const online_status = await checkOnline();

		console.log("Updating Online Status...");
		if( online_status === "online" ){
			document.getElementById("offline_label").innerHTML = "YOU'RE ONLINE";
			await checkForPendingStoreAndExecute();
		}else{
			document.getElementById("offline_label").innerHTML = "YOU'RE OFFLINE. SERVER WILL NOT BE UPDATED WITH ANY NEW SAVES.";
		}
	}

	// Whenever burst store succeeds, clear the update flag so it doesn't get auto-updated when coming back online.
	function unsetUpdateFlag(){
		console.log("Clearing pending Burst Store update flag.");
		document.getElementById("offline_dbase_update_flag").innerHTML = "";
	}

	// If burst store fails because we're offline, set flag to try burst store next time we check.
	function setUpdateFlag(){
		console.log("Setting pending Burst Store update flag.");
		document.getElementById("offline_dbase_update_flag").innerHTML = "pending";
	}

	// Check for pending offline dbase store and try to execute it.
	async function checkForPendingStoreAndExecute(){
		console.log("Checking for pending Burst Store...");
		const update_flag = document.getElementById("offline_dbase_update_flag").innerHTML;
		if( update_flag !== ""){
			console.log("Pending Burst Store found! Execute it.");
			// If update_flag is NOT empty, we need to execute a burst store.
			const burst_save_response = await sendOfflineDBaseToServer();
			if( burst_save_response != null){
				console.log("Result of pending Burst Store response: " + burst_save_response.response);
				if( burst_save_response.response === "success"){
					console.log("Pending Burst Store successfully executed!");
					// On successful burst store, clear update_flag.
					unsetUpdateFlag();
				}else{
					console.log("Pending Burst Store FAILED!");
					// On unsuccessful burst store, set update_flag.
					setUpdateFlag();
				}
			}else{
				console.log("Pending Burst Store FAILED!");
				// On unsuccessful burst store, set update_flag.
				setUpdateFlag();
			}
		}
	}

	// We need to set the origin differently depending if we're a standalone file or not.
	// This function checks our origin and sets it to the server url to enable server functionality for a standalone.html.
	// Returns the SERVER_URL to be used for server communication functions.
	function getServerOrigin(){
		// Check origin.
		console.log("window.location.origin = " + window.location.origin);
		const url_origin = window.location.origin;
		let server_origin = '';
		// If we're standalone, set address to chat.dance instead of a relative path.
		const regex = /^file/;
		if( regex.test(url_origin) ){
			console.log("We're a standalone file!");
			server_origin = 'https://chat.dance/obf/';
		}else{
			console.log("We're NOT a standalone file!");
			server_origin = '/obf/';
		}
		return server_origin;
	}

	// Check if we're online 
	async function checkOnline(){
		let SERVER_URL = getServerOrigin();
		SERVER_URL += 'exeonlinecheck';
		
		console.log("Checking Online...");
		const response = await fetch(SERVER_URL, {
			method: 'POST',
			headers: {
				'Content-Type': 'text/plain',
			}
		})
		.catch((error) => {
			// If we're in this error block we know that it is a communication/offline error. Yes this is arcane knowledge.
			console.log("Fetch Error on Online Check: " + error.message);
			console.log("response FAILED");
			return "offline";
		});
		if( response.ok ){
			console.log("Response from checkOnline() fetch() call = OK!");
			return "online";
		} else {
			console.log("HTTP error. Status: " + response.status);
		}
	}

	// Endpoint /obf/exeload will attempt to load encrypted data corresponding to the input fingerprint.
	// This type of URI used instead of a direct link to the file for security.
	// Input: fingerprint is hexadecimal.
	// Output: POST message to server script which will attempt to Access.
	async function serverLoad(fingerprint){
		let SERVER_URL = getServerOrigin();
		SERVER_URL += 'exeload';
		
		//debug("serverLoad() -- Attempting Server Load with\nFingerprint: " + fingerprint); 
		const response = await fetch(SERVER_URL, {
			method: 'POST',
			headers: {
				'Content-Type': 'text/plain',
			},
			body: JSON.stringify({
				fingerprint: fingerprint,
			}),
		})
		.catch((error) => {
			console.log("Fetch Error on serverLoad!~: " + error.message);
			if( error.message == "Failed to fetch" ){
				console.log("WE'VE SUCCESSFULLY CAUGHT THE DISCONNECTED ERROR!~");
			}
		});
		if( response ){
			if( response.ok ){
				console.log("Response from serverLoad() fetch() call = OK!");
				return response.json();
			} else {
				console.log("HTTP error. Status: " + response.status);
				return response.json();
			}
		}
		return;
	}//serverLoad()

	// Endpoint exestore will attempt to store.
	// input encrypted data at the input fingerprint location.
	// Inputs: fingerprint is hex, data is base64.
	// Output: POST message to server script which will attempt to Store.
	async function serverStore(fingerprint, data){
		let SERVER_URL = getServerOrigin();
		SERVER_URL += 'exestore;';
		
		////debug("Attempting Server Store.\nFingerprint: " + fingerprint + "\nData: " + data + "\nUpload Flag: " + upload_flag_db + "\n");
		//debug("ser100%verStore() -- Attempting Server Store.\nFingerprint: " + fingerprint + "\nData: " + data + "\n");
		const response = await fetch(SERVER_URL, {
			method: 'POST',
			headers: {
				'Content-Type': 'text/plain',
			},
			body: JSON.stringify({
				fingerprint: fingerprint,
				data: data,
			}),
		})
		.catch((error) => {
			console.log("Fetch Error on serverStore!~: " + error.message);
			if( error.message == "Failed to fetch" ){
				console.log("CAUGHT THE DISCONNECTED ERROR IN STORE!~");
			}
		});
		if( response ){
			if( response.ok ){
				console.log("Response from serverStore() fetch() call = OK!");
				return response.json();
			} else {
				console.log("HTTP error. Status: " + response.status);
				return response.json();
			}
		}
		return;
	}//serverStore()

	async function serverSetPasslock(browser_id, passlock){
		let SERVER_URL = getServerOrigin();
		SERVER_URL += 'exesetpasslock;';
		
		const response = await fetch(SERVER_URL, {
			method: 'POST',
			headers: {
				'Content-Type': 'text/plain',
			},
			body: JSON.stringify({
				browser_id: browser_id,
				passlock: passlock,
			}),
		})
		.catch((error) => {
			console.log("Fetch Error on serverSetPasslock : " + error.message);
			if( error.message == "Failed to fetch" ){
				console.log("CAUGHT THE DISCONNECTED ERROR IN SetPasslock!");
			}
		});
		if( response ){
			if( response.ok ){
				console.log("Response from serverSetPasslock() fetch() call = OK!");
				return response.json();
			} else {
				console.log("HTTP error. Status: " + response.status);
				return response.json();
			}
		}
		return;
	}//serverSetPasslock()

	async function serverGetPasslock(){
		const browser_id = browser_id_global;
		let SERVER_URL = getServerOrigin();
		SERVER_URL += 'exegetpasslock;';
		
		const response = await fetch(SERVER_URL, {
			method: 'POST',
			headers: {
				'Content-Type': 'text/plain',
			},
			body: JSON.stringify({
				browser_id: browser_id,
			}),
		})
		.catch((error) => {
			console.log("Fetch Error on serverGetPasslock : " + error.message);
			if( error.message == "Failed to fetch" ){
				console.log("CAUGHT THE DISCONNECTED ERROR IN GetPasslock!");
			}
		});
		if( response ){
			if( response.ok ){
				console.log("Response from serverGetPasslock() fetch() call = OK!");
				return response.json();
			} else {
				console.log("HTTP error. Status: " + response.status);
				return response.json();
			}
		}
		return;
	}//serverGetPasslock()

	// Create a json string containing every record in the offline dbase from 0 to pointer.
	function convertOfflineDBaseToJSONString(){
		const offline_dbase = document.getElementById("offline_dbase").innerHTML;
		const offline_dbase_pointer = document.getElementById("offline_dbase_pointer").innerHTML;

		// Compose the flat json string manually.
		let offline_dbase_json_flat = '{"records":[';

		let fp_start;
		let fp_end;
		let data_end;
		for(let i=0; i < offline_dbase_pointer; i++ ){
			fp_start = i * 1064;
			fp_end = fp_start + 64;
			data_end = fp_end + 1000;

			offline_dbase_json_flat += '{"fingerprint":"' + offline_dbase.substring(fp_start, fp_end) + '",';
			offline_dbase_json_flat += '"data":"' + offline_dbase.substring(fp_end, data_end) + '"},';
		}
		// Remove last error causing comma , 
		offline_dbase_json_flat = offline_dbase_json_flat.slice(0, -1);
		offline_dbase_json_flat += ']}';

		return offline_dbase_json_flat;
	}

	// Inputs: none but pulls data from offline dbase object.
	// Output: sends a json string representation of the offline dbase 
	// 		to server where it will be decoded and saved.
	async function sendOfflineDBaseToServer(){
		// Need a JSon object -- records: [ fp: fp, data: data ]
		// Make the string in a separate function.
		let offline_dbase_json_string = convertOfflineDBaseToJSONString();
		console.log("manually composed json string: " + offline_dbase_json_string);

		let SERVER_URL = getServerOrigin();
		SERVER_URL += 'exeburststore;';
		////debug("Attempting Server BURST Store of the Offline Database.");
		const response = await fetch(SERVER_URL, {
			method: 'POST',
			headers: {
				'Content-Type': 'text/plain',
			},
			body: offline_dbase_json_string,
		})
		.catch((error) => {
			console.log("Fetch Error on BURST Store (sendOfflineDBaseToServer)!~: " + error.message);
			if( error.message == "Failed to fetch" ){
				console.log("CAUGHT THE DISCONNECTED ERROR IN BURST STORE!~");
				// Set pending Burst Store update flag == we failed to run it so need to when we next come online.
				setUpdateFlag();
			}
		});
		if( response ){
			if( response.ok ){
				console.log("Response from sendOfflineDBaseToServer() fetch() call = OK!");
				return response.json();
			} else {
				console.log("HTTP error. Status: " + response.status);
				return response.json();
			}
		}
		return;
	}//sendOfflineDBaseToServer()

	// Endpoint /obf/exedelete will attempt to delete.
	// Input: fingerprint is hexadecimal.
	// Output: POST message to server script that will attempt to Delete.
	async function serverDelete(fingerprint){
		//const SERVER_URL = '/obf/exedelete';
		let SERVER_URL = getServerOrigin();
		SERVER_URL += 'exedelete;';
		
		//debug("serverDelete() -- Attempting Server Delete with\nFingerprint: " + fingerprint); 
		const response = await fetch(SERVER_URL, {
			method: 'POST',
			headers: {
				'Content-Type': 'text/plain',
			},
			body: JSON.stringify({
				fingerprint: fingerprint,
			}),
		})
		.catch((error) => {
			console.log("Fetch Error on DELETE: " + error.message);
			if( error.message == "Failed to fetch" ){
				console.log("CAUGHT THE DISCONNECTED ERROR IN DELETE.");
			}
		});
		if( response ){
			if( response.ok ){
				console.log("Response from serverDelete() fetch() call = OK!");
				return response.json();
			} else {
				console.log("HTTP error. Status: " + response.status);
				return response.json();
			}
		}
		return;
	}//serverDelete()


	//////////////////////////////////////////////////////////////
	//				Cryptographic Functions					    //
	//////////////////////////////////////////////////////////////
	// Our implementation of OpenSSL's encrypt function.
	// Inputs: Plaintext.
	// Output: OpenSSL encrypted base64 string.
	async function encOpenSSL(plaintext, pass, iter=10000, digest_hash="SHA-256" , digest_algorithm="AES-CBC") {
		// Prepare plaintext for encryption.
		// Encode plaintext in utf8 and store in Uint8Array inputbytes.
		const inputbytes = new TextEncoder().encode( plaintext );
		document.getElementById("dev_enc_openssl_plaintext_bytes").value = inputbytes;

		// Make the plaintext look like a file by adding a single newline char to the end of the string.
		const single_newline = new Uint8Array(1);
		// utf8 newline code is the value 10(decimal).
		single_newline[0] = 10;
		// Merge the two Uint8Arrays.
		const plaintextbytes = concatBuffer(inputbytes, single_newline);
		document.getElementById("dev_enc_openssl_plaintext_with_newline").value = plaintextbytes;

		// Prepare inputs for digest.
		//const iter = 10000;
		//const digest_hash = 'SHA-256';
		// Generate random salt.
		//let salt = new Uint8Array(8);
		let salt;
		if( document.getElementById("dev_enc_openssl_derivebits_salt").value.trim() === ""){
			salt = window.crypto.getRandomValues(new Uint8Array(8));
			document.getElementById("dev_enc_openssl_derivebits_salt").value = salt;
			document.getElementById("dev_enc_openssl_encrypted_salt_random").value = salt;
		}else{
			saltstring = document.getElementById("dev_enc_openssl_derivebits_salt").value;
			// Convert string of ints into an array (numbers).
			const numbers = saltstring.split(',').map(Number);
			if( numbers.length != 8 ){
				alert("Invalid Random Salt!\n\nManually inputted salt must be exactly 8 bytes in comma separated number form.");
				throw new Error("Manually inputted salt must be exactly 8 bytes.");
			}
			salt = new Uint8Array(numbers);
			document.getElementById("dev_enc_openssl_encrypted_salt_random").value = salt;
		}

		// Salt is used when hashing, IV (Initialization Vector) for encryption.

		const encoded_pass = new TextEncoder().encode(pass);
		document.getElementById("dev_enc_openssl_password_bytes").value = encoded_pass;
		// Import password into a subtlecrypto-usable key object.
		const keyMaterial = await getKeyMaterial(encoded_pass);
		// Derives input bits used for the PBKDF2 cryptoKey object AND the IV.
		const derived_bits = await window.crypto.subtle.deriveBits(
			{
				name: "PBKDF2",
				//name: key_derivation_algo,
				salt,
				iterations: iter,
				hash: digest_hash,
			},
			keyMaterial,
			384,
		);
		const derivedKeyBuffer = new Uint8Array(derived_bits);
		//debug("Password Flow encOpenSSL() -- PBKDF2 Derived Bits - 384 bits:\n" + derivedKeyBuffer);

		// OpenSSL derives the key and IV using the same PBKDF2 digest.
		// The first 256 bits are used as key, the last 128 are used for IV.
		const keybytes = derivedKeyBuffer.slice(0, 32);
		//debug("Password Flow encOpenSSL() -- PBKDF2 Derived Bits - Lower 256 - Key:\n" + keybytes);
		const ivbytes = derivedKeyBuffer.slice(32);
		//debug("Password Flow encOpenSSL() -- PBKDF2 Derived Bits - Upper 128 - Initialization Vector (IV):\n" + ivbytes);

		document.getElementById("dev_enc_openssl_encrypt_iv").value = ivbytes;
		document.getElementById("dev_enc_openssl_encrypt_key").value = keybytes;
		// Import the PBKDF2 derived key bits into a key object made specifically 
		// for use with the aes-cbc 256 algorithm.
		// MDN syntax: importKey(format, keyData, algorithm, extractable, keyUsages)
		let key = await window.crypto.subtle.importKey(
			'raw', 
			keybytes, 
			{
				//name: 'AES-CBC', 
				name: digest_algorithm,
				length: 256
			}, 
			false, 
			['encrypt']
		);
		//debug("Data Flow encOpenSSL() -- AES-CBC 256 Encryption Inputs:");
		//debug("Data Flow encOpenSSL() -- AES-CBC 256 Input - Key:");
		//debug(key);
		//debug("Data Flow encOpenSSL() -- AES-CBC 256 Input - IV:\n" + ivbytes);
		//debug("Data Flow encOpenSSL() -- AES-CBC 256 Input - Binary Data:\n" + plaintextbytes);
		// Main Function Digest
		// MDN syntax: encrypt(algorithm, key, data)
		//const encrypted_result = await window.crypto.subtle.encrypt({ name: "AES-CBC", iv: ivbytes }, key, plaintextbytes);
		const encrypted_result = await window.crypto.subtle.encrypt({ name: digest_algorithm, iv: ivbytes }, key, plaintextbytes);
		// Data Flow Window
		const log_encrypted_result = new Uint8Array(encrypted_result);
		//debug("Data Flow encOpenSSL() -- AES-CBC 256 Encrypted Output Data:\n" + log_encrypted_result);
		document.getElementById("dev_enc_openssl_encrypted_data").value = log_encrypted_result;
		// Combine (OpenSSL hardcoded) constant salt, random salt, and encrypted result as array buffers, then convert to base64.
		const const_salt = "Salted__";	// OpenSSL hardcoded.
		const saltbytes = new TextEncoder().encode(const_salt);
		document.getElementById("dev_enc_openssl_encrypted_salt_string").value = saltbytes;
		const two_salts = concatBuffer(saltbytes, salt);
		// Merge salts with encoded ciphertext.
		// encrypted_output_buf = Salted__(binary) + <random salt bytes> + <data cipherbytes>
		const encrypted_output_buf = concatBuffer(two_salts, encrypted_result);
		//debug("Data Flow encOpenSSL() -- Encrypted Data with 2 added Salts:\n" + encrypted_output_buf);
		document.getElementById("dev_enc_openssl_encrypted_data_two_salts").value = encrypted_output_buf;
		let out64 = bytesToBase64(encrypted_output_buf);
		//debug("Data Flow encOpenSSL() -- Encrypted Data in base64 - encOpenSSL() Output:\n" + out64);
		return out64;
	}//encOpenSSL()

	// Our implementation of OpenSSL's decrypt function.
	// Inputs: ciphertext64 is base64. pass is plaintext.
	// Output: decrypted plaintext.
	//async function decOpenSSL(ciphertext64, pass, iter=10000, digest_hash=, digest_algorithm) {
	async function decOpenSSL(ciphertext64, pass, iter=10000, digest_hash="SHA-256" , digest_algorithm="AES-CBC") {
		//debug("Data Flow decOpenSSL() -- Ciphertext Input - base64:\n" + ciphertext64);
		// Convert input base 64 to binary.
		const ciphertextbytes = base64ToBytes(ciphertext64);
		document.getElementById("dev_dec_openssl_ciphertext_bytes").value = ciphertextbytes;
		//debug("Data Flow decOpenSSL() -- Ciphertext - Binary:\n" + ciphertextbytes);
		// ciphertext is now in a form that is ready to give to the encryption function.

		// Prepare inputs for digest.
		//const digest_hash = 'SHA-256';
		//const iter = 10000;
		// Salt has been preserved from encrypt. Pull digits from their place in the ciphertext.
		const salta = ciphertextbytes.slice(8,16);
		document.getElementById("dev_dec_openssl_derivebits_salt").value = salta;
		const salt = new Uint8Array(salta);
		//debug("Data Flow decOpenSSL() -- Ciphertext - Extracted Salt (bytes 8-15):\n" + salt);

		// Use the key derivation function PBKDF2 to derive bits that will 
		// be used to create the cryptoKey object needed for the main digest.
		const encoded_pass = new TextEncoder().encode(pass);
		document.getElementById("dev_dec_openssl_password_bytes").value = encoded_pass;
		const keyMaterial = await getKeyMaterial(encoded_pass);
		//debug("Password Flow decOpenSSL() -- Plaintext password input:\n" + pass);
		const derived_bits = await window.crypto.subtle.deriveBits(
			{
				name: "PBKDF2",
				salt,
				iterations: iter,
				hash: digest_hash,
			},
			keyMaterial,
			384,
		);
		const derivedKeyBuffer = new Uint8Array(derived_bits);

		// OpenSSL derives the key and IV using the same PBKDF2 digest.
		// The first 256 bits are used as key, the last 128 are used for IV.
		const keybytes = derivedKeyBuffer.slice(0, 32);
		document.getElementById("dev_dec_openssl_decrypt_key").value = keybytes;
		const ivbytes = derivedKeyBuffer.slice(32);
		document.getElementById("dev_dec_openssl_decrypt_iv").value = ivbytes;

		// Extract the encrypted phrase (data) from OpenSSL input
		const cipherbytesphrase = ciphertextbytes.slice(16);
		document.getElementById("dev_dec_openssl_ciphertext_extracted_bytes").value = cipherbytesphrase;

		// Data Window Logging
		//debug("Password Flow decOpenSSL() -- PBKDF2 Derived Bits - 384 bits:\n" + derivedKeyBuffer);
		////debug(derivedKeyBuffer);
		//debug("Password Flow decOpenSSL() -- PBKDF2 Derived Bits - Lower 256 - Key:\n" + keybytes);
		//debug("Password Flow decOpenSSL() -- PBKDF2 Derived Bits - Upper 128 - Initialization Vector (IV):\n" + ivbytes);

		// Import the PBKDF2 derived key bits into a key object made specifically 
		// for use with the aes-cbc 256 algorithm.
		// MDN syntax: importKey(format, keyData, algorithm, extractable, keyUsages)
		let key = await window.crypto.subtle.importKey(
			'raw', 
			keybytes, 
			{
				//name: 'AES-CBC', 
				name: digest_algorithm, 
				length: 256
			}, 
			false, 
			['decrypt']
		);

		// Data Window Logging
		//debug("Data Flow decOpenSSL() -- AES-CBC 256 Decryption Inputs:");
		//debug("Data Flow decOpenSSL() -- AES-CBC 256 Decrypt - Key:");
		//debug(key);
		//debug("Data Flow decOpenSSL() -- AES-CBC 256 Decrypt - IV:\n" + ivbytes);
		//debug("Data Flow decOpenSSL() -- AES-CBC 256 Decrypt - Binary Data:\n" + cipherbytesphrase);
		// Main Function Call
		// MDN syntax: decrypt(algorithm, key, data)
		//const decrypted_result = await window.crypto.subtle.decrypt({ name: "AES-CBC", iv: ivbytes }, key, cipherbytesphrase);
		const decrypted_result = await window.crypto.subtle.decrypt({ name: digest_algorithm, iv: ivbytes }, key, cipherbytesphrase);
		const log_decrypted_result = new Uint8Array(decrypted_result);
		document.getElementById("dev_dec_openssl_decrypted_bytes").value = log_decrypted_result;
		//debug("Data Flow decOpenSSL() -- Decrypted Binary Data:\n" + log_decrypted_result);
		// Convert bytes to string.
		let decrypted_string = new TextDecoder().decode( decrypted_result );
		// Pop single newline added in enc (openssl emulation).
		decrypted_string = decrypted_string.substring(0, decrypted_string.length - 1);
		//debug("Data Flow decOpenSSL() -- Decrypted String - decOpenSSL() Output:");
		//debug(decrypted_string);
		return decrypted_string;
	}//decOpenSSL()

	// Process plaintext password into a Key Object usable by subtlecrypto functions.
	// Input: Plaintext password.
	// Output: Subtlecrypto usable Key Object.
	function getKeyMaterial(encoded_pass) {
		//const enc = new TextEncoder();
		//const encoded_pass = new TextEncoder().encode( password );
		//debug("Password Flow getKeyMaterial() -- Encoded Password: " + encoded_pass);
		//document.getElementById("dev_enc_openssl_password_bytes").value = encoded_pass;
		// importKey(format, keyData, algorithm, extractable, keyUsages)
		return window.crypto.subtle.importKey(
			"raw",
			//enc.encode(password),	// plaintext -> binary
			encoded_pass,	// plaintext -> binary
			"PBKDF2",
			//algo,
			false,
			["deriveBits", "deriveKey"],
		);
	}//getKeyMaterial()

	// Encrypting function that prepends a countstring, then runs an XOR on the byte arrrays of the input data and password,
	// and finally converts the result to a specific length output of 1000 base 64 character string.
	// Inputs: plaintext64 is base64, password is plaintext.
	// Outputs: 1000 characters of base64 string.
	async function obf1Encrypt(plaintext64, password) {
		// Add our custom countstring to the data.
		let plaintext_binary = addCountstring(plaintext64);
		document.getElementById("dev_enc_obf1_zero_padded_data").value = plaintext_binary;

		if( !checkBase64Chars(plaintext64) ){
			throw new Error('Obfuscation step 1 INVALID characters found!');
		}

		// With conversion to base64, 750 bytes convert to 1000 base64 chars exactly.
		const array_length = 750;

		// Prepare password side for XOR.
		const password_binary = new TextEncoder().encode(password);
		document.getElementById("dev_enc_obf1_password_bytes").value = password_binary;
		const pass_binary = await getPassHash(password_binary, array_length);
		document.getElementById("dev_enc_obf1_sha_extended_bytes").value = pass_binary;

		// Perform the XOR bitwise byte by byte.
		let xor_result = new Array();
		// XOR is a ^ in javascript
		for (let i = 0; i < array_length; i++) {
			xor_result.push(pass_binary[i] ^ plaintext_binary[i]);
		}

		let result_b64 = bytesToBase64(xor_result);
		document.getElementById("dev_enc_obf1_xord_data").value = result_b64;
		return result_b64;
	}//obf1Encrypt()

	// obf1Decrypt() is the inverse function of obf1Encrypt().
	// Inputs: ciphertext64 is a base64 string, password is plaintext
	// Output: decrypted_string is a base64 string
	async function obf1Decrypt(ciphertext64, password) {
		// Convert base64 string to Uint8Array of bytes.
		let decoded_b64_array = base64ToBytes(ciphertext64);
		// Devsite window functrion.
		document.getElementById("dev_dec_obf1_ciphertext_bytes").value = decoded_b64_array;

		// Constant array length. 750 is the total bytes that will fit into 1000 base64 chars.
		let array_length = 750;
		// Compute password for XOR.
		const password_binary = new TextEncoder().encode(password);
		document.getElementById("dev_dec_obf1_password_bytes").value = password_binary;
		let pass_binary = await getPassHash(password_binary, array_length);
		document.getElementById("dev_dec_obf1_sha_extended_bytes").value = pass_binary;

		// Inverse of XOR is XOR and is communicative.
		// XOR password and output to get input.
		// Regular Array needed for shift, pop.
		let xor_result = new Array();
		// XOR is typically the carrot char: ^ 
		for (let i = 0; i < array_length; i++) {
			xor_result.push(pass_binary[i] ^ decoded_b64_array[i]);
		}
		document.getElementById("dev_dec_obf1_xor_inversed_data").value = xor_result;
		console.log("xor_result length: " + xor_result.length);

		// Decode to show user in dev site.
		// Decoder works on uint8array's.
		data_uint8 = Uint8Array.from(xor_result);
		// Converts bytes to javascript String:
		// https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder
		const with_countstring = new TextDecoder().decode(data_uint8);
		document.getElementById("dev_dec_obf1_data_with_countstring").value = with_countstring;

		// The number of digits for the countstring will be either 1, 2, or 3 as the data length is limited to a number less than 1000 chars.
		// First shift off 1 byte from the beginning of the array, which will be a number byte.
		// Then push that shifted byte onto a new array to be converted into a number later.
		//
		// shift(), pop() reduce the size of target array by 1.
		let shifted_byte = xor_result.shift();
		console.log("shifted byte = " + shifted_byte);
		// Need explicit instantiation for push to work on new variable.
		let length_array = new Array;
		length_array.push(shifted_byte);
		// We've shifted off 1 byte, so we won't enter the while loop if there's 1 length digit.
		// Shift bytes from countstring decrypted array to length_array until we hit the colon byte.
		while( xor_result[0] != 58 ){
			//console.log("xor_result while looping : " + xor_result);
			shifted_byte = xor_result.shift();
			length_array.push(shifted_byte);
		}
		// Shift off colon byte. It's done its job.
		//shifted_byte = xor_result.shift();
		xor_result.shift();

		// Convert bytes to a number.
		length_array = Uint8Array.from(length_array);
		const data_length = new TextDecoder().decode(length_array);
		console.log("countstring extracted length value: " + data_length);

		// Remove zeros by slicing off everything after the data bytes end.
		xor_result = xor_result.slice( 0, data_length );
	
		// Array needs to be Uint8Array for Decode to work.	
		// Should now be stripped of zeros and countstring, leaving data.
		const plaintextbytes = Uint8Array.from(xor_result);
		// Decode precisely stripped array.
		let output = new TextDecoder().decode(plaintextbytes);
		return output;
	}//obf1Decrypt

	// Encrypting function that adds each index pair of the input_data and password,
	// then takes the modulo of that result to build an ecrypted string of 1000 base64 characters.
	// Inputs: input_data is 1000 characters of base64 string, password is plaintext
	// Output: 1000 chars of base64 string
	async function obf2Encrypt(input_data, password){

		if( !checkBase64Chars(input_data) ){
			throw new Error('Obfuscation step 2 INVALID characters found!');
		}

		// Get size of input data. Should be 1000.
		const input_length = input_data.length;

		// Hash, rehash, append password function.
		const password_binary = new TextEncoder().encode(password);
		document.getElementById("dev_enc_obf2_password_bytes").value = password_binary;
		const pass_hash = await getPassHash(password_binary, input_length);
		document.getElementById("dev_enc_obf2_sha_extended_bytes").value = pass_hash;

		pass_b64 = bytesToBase64(pass_hash);
		document.getElementById("dev_enc_obf2_password_b64").value = pass_b64;

		// Create 2 arrays of length 1000.
		let input_b64_num_arr = new Array(input_length);
		let pass_b64_num_arr = new Array(input_length);
		for (let i = 0; i < input_length; i++) {								// input_length should be 1000
			// Convert each b64 character to its numerical index and store in an array. 
			input_b64_num_arr[i] = base64map.indexOf(input_data.charAt(i));		// 1000 chars long
			pass_b64_num_arr[i] = base64map.indexOf(pass_b64.charAt(i));		// there is more data in pass_b64 but we don't use it.
		}

		// Add each index pair and store in new array.
		let sum_b64_num_arr = new Array(input_length);
		for (let i = 0; i < input_length; i++) {
			sum_b64_num_arr[i] = input_b64_num_arr[i] + pass_b64_num_arr[i];
		}

		// Take the 64 modulo of each index.
		for (let i = 0; i < input_length; i++) {
			sum_b64_num_arr[i] = sum_b64_num_arr[i] % 64;
		}

		// Convert each processed index to b64 characters.
		let final_encrypted_string = '';
		for (let i = 0; i < input_length; i++) {
			final_encrypted_string += base64map.charAt(sum_b64_num_arr[i]);
		}

		return final_encrypted_string;
	}//obf2Encrypt()

	// Decrypting function that takes the inverse of obf2Encrypt().
	// Inputs: final_encrypted is 1000 characters of base64 string, password is plaintext
	// Output: final_decrypted_string is 1000 chars of base64 string
	async function obf2Decrypt(final_encrypted, password){

		// Get size of input data. Should be 1000.
		const final_encrypted_length = final_encrypted.length;

		// Hash, rehash, append password function.
		const password_binary = new TextEncoder().encode(password);
		document.getElementById("dev_dec_obf2_password_bytes").value = password_binary;
		const pass_hash = await getPassHash(password_binary, final_encrypted_length);
		document.getElementById("dev_dec_obf2_sha_extended_bytes").value = pass_hash;

		// Convert password hash byte array to base64 string.
		const pass_b64 = bytesToBase64(pass_hash);
		document.getElementById("dev_dec_obf2_password_b64").value = pass_b64;

		// Convert each operand b64 string to an array of corresponding indices.
		// Create 2 arrays of length 1000.
		let final_encrypted_b64_num_arr = new Array(final_encrypted_length);
		let pass_b64_num_arr = new Array(final_encrypted_length);
		for (let i = 0; i < final_encrypted_length; i++) {
			// Convert each b64 character to its numerical index. 
			final_encrypted_b64_num_arr[i] = base64map.indexOf(final_encrypted.charAt(i));
			pass_b64_num_arr[i] = base64map.indexOf(pass_b64.charAt(i));
		}

		// Run the inverse of the sum-and-64-modulo encrypt function.
		let in_b64_num_arr = new Array(final_encrypted_length);
		for (let i = 0; i < final_encrypted_length; i++) {
			// If the difference is negative, we know the input got modulo'd and needs that 64 back to produce the inverse data.
			// Now we can decrypt by taking the difference of each index pair.
			in_b64_num_arr[i] = final_encrypted_b64_num_arr[i] - pass_b64_num_arr[i];
			if( in_b64_num_arr[i] < 0 ){
				in_b64_num_arr[i] += 64;
			}
		}

		// Convert the resulting numerical values to b64 chars.
		let final_decrypted_string = '';
		for (let i = 0; i < final_encrypted_length; i++) {
			final_decrypted_string += base64map.charAt(in_b64_num_arr[i]);
		}

		return final_decrypted_string;
	}//obf2Decrypt()

	// Encrypt stack used in the case user chooses command line.
	async function encryptDouble(file_ingest_input, pass2, pass3){
		// Obfuscation Step 1 Encrypt
		const obf_s1_encrypted = await obf1Encrypt(file_ingest_input, pass2);
		// Obfuscation Step 2 Encrypt
		const obf_s2_encrypted = await obf2Encrypt(obf_s1_encrypted, pass3);
		return obf_s2_encrypted;
	}//encryptDouble()

	// Encrypt stack used in the case user chooses Browser.
	async function encryptStack(plaintext, pass1, pass2, pass3){
		// OpenSSL Encrypt (base 64 encoded)
		const openssl_encrypted = await encOpenSSL(plaintext, pass1);
		// Obfuscation Step 1 Encrypt
		const obf_s1_encrypted = await obf1Encrypt(openssl_encrypted, pass2);
		// Obfuscation Step 2 Encrypt
		const obf_s2_encrypted = await obf2Encrypt(obf_s1_encrypted, pass3);
		return obf_s2_encrypted;
	}//encryptStack()

	// Decrypt stack used in the case user chooses Command Line.
	async function decryptDouble(encrypted, pass2, pass3){
		const obf2_decrypted = await obf2Decrypt(encrypted, pass3);
		const obf1_decrypted = await obf1Decrypt(obf2_decrypted, pass2);
		return obf1_decrypted;
	}//decryptStack()

	// Decrypt stack used in the case user chooses Browser.
	async function decryptStack(encrypted, pass1, pass2, pass3){
		const obf2_decrypted = await obf2Decrypt(encrypted, pass3);
		const obf1_decrypted = await obf1Decrypt(obf2_decrypted, pass2);
		const plaintext = await decOpenSSL(obf1_decrypted, pass1);
		return plaintext;
	}//decryptStack()

	// SHA-256 hash inputs, concatenate them, then return a hash of that concatenation.
	// Inputs: plaintext.
	// Output: hexadecimal.
	async function computeFingerprint(codeword, pass_2, pass_3){
		// Convert to lowercase.
		const cw_lower = codeword.toLowerCase();
		//debug("computeFingerprint() -- Lowercase Codeword: " + cw_lower); 
		//debug("computeFingerprint() -- Password 2: " + pass_2); 
		//debug("computeFingerprint() -- Password 3: " + pass_3); 
		// Take SHA-256 hash of codeword, pass 2, pass 3.
		const enc = new TextEncoder();
		const cw_buf = enc.encode(cw_lower);
		const p2_buf = enc.encode(pass_2);
		const p3_buf = enc.encode(pass_3);
		//debug("computeFingerprint() -- Binary Codeword: " + cw_buf); 
		//debug("computeFingerprint() -- Binary Password 2: " + p2_buf); 
		//debug("computeFingerprint() -- Binary Password 3: " + p3_buf); 
		const cw_hash = await crypto.subtle.digest('SHA-256', cw_buf);
		const p2_hash = await crypto.subtle.digest('SHA-256', p2_buf);
		const p3_hash = await crypto.subtle.digest('SHA-256', p3_buf);
		// Concatenate: fingerprint = cw_hash + p2_hash + p3_hash
		const cw_and_p2_hash = concatBuffer(cw_hash, p2_hash)
		const concatenated_hashes = concatBuffer(cw_and_p2_hash, p3_hash)

		// SHA-256 hash the result.
		const fp_hash = await crypto.subtle.digest('SHA-256', concatenated_hashes);
		const fingerprint = new Uint8Array(fp_hash);
		//debug("computeFingerprint() -- Binary Fingerprint:\n" + fingerprint); 
		////debug("Computed Fingerprint: " + fingerprint);
		const fp_hex = buf2hex(fingerprint);
		//debug("computeFingerprint() -- base64 Fingerprint: " + fp_hex); 
		return fp_hex;
	}//computeFingerprint

	// Input: input is a string.
	// Output: Returns false if non-base58 characters are detected.
	function checkBase64Chars(input){
		// From the first char(^) to the last($), match exactly 1000 base64 chars.
		const regex = /^[a-zA-Z0-9\+\/\=]*$/;
		if( regex.test(input) ){
			// Return true/valid: non-b58 chars were NOT found.
			return 1;
		}else{
			// Return false/invalid: non-b58 chars were found.
			return 0;
		}
	}//checkBase64Chars()

	// Input: input is a string.
	// Output: Returns false if the input length (in bytes) is over 700.
	function checkInputLength(input){
		// show input size in bytes
		let size = new Blob([input]).size;
		let difference = 526 - size;
		// Show running count of data length.
		let size_string = "Byte length remaining: " + difference;
		document.getElementById("data_length_label").innerHTML = size_string;
		
		if( size > 526 ){
			return 0; // Length Check Failed.
		}else{
			return 1; // Length Check Passed.
		}
	}//checkInputLength()

	// Prepends a string equal to the length of the input base64 string to the front of that string in readable format.
	// Input: varying length string of base64 data.
	// Output: string with number then colon then input data: 10:<data of length 10>
	function addCountstring(data) {
		// Count chars.
		const num_chars = data.length;
		// Form 'countstring'
		let countstring = num_chars + ':' + data;
		document.getElementById("dev_enc_obf1_b64_with_countstring").value = countstring;
		// Convert to binary (Uint8Array).
		const countstring_binary = new TextEncoder().encode(countstring);
		// Create uint8array of length 750 as this will be used for obf1 XOR.
		let big_arr = new Uint8Array(750);
		// Copy countstring_binary into big_arr matching index 0 to index 0, 1 to 1, etc.
		big_arr.set(countstring_binary);
		return big_arr;
	}//addCountstring()

	// Create a SHA-256 hash of the pass, then rehash and append to size: length.
	// Inputs: pass is plaintext, length is an integer 
	// Output: binary byte array (Uint8Array).
	async function getPassHash(password_binary, length) {
		// Take initial SHA256.
		let sha_cumulative = await crypto.subtle.digest('SHA-256', password_binary);
		let	sha_result;
		// Loop until we have more than the input length number of bytes of data.
		do{
			sha_result = await crypto.subtle.digest('SHA-256', sha_cumulative);
			// Append SHA256 of Hash(n-1)
			sha_cumulative = concatBuffer(sha_cumulative, sha_result);
		} while( sha_cumulative.length < length);
		// Truncate array to size <length>
		sha_cumulative = sha_cumulative.slice(0, length);
		return sha_cumulative;
	}//getPassHash()

	// Concatenates ArrayBuffers.
	// Inputs: buffer1, buffer2 are tested as working if they are buffers or Uint8Arrays.
	// Output: return = buffer1 concatenated with buffer2 in order buffer1, then buffer2.
	// There doesn't appear to be a native array merge for typed arrays like Uint8Array (their length is fixed).
	function concatBuffer(buffer1, buffer2) {
		// Create new uint8array with size of buffer1 length + buffer 2 length.
		let tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
		// Set left part of the array to buffer 1.
		tmp.set(new Uint8Array(buffer1), 0);
		// Set right part of the array to buffer 2.
		tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
		// Return the uint8array (which contains underlying ArrayBuffer which contains raw binary data)
		return tmp;
	}//concatBuffer()

	// Code for function found here:
	// https://developer.mozilla.org/en-US/docs/Web/API/Window/btoa
	// MDN funcction Usage:
	// bytesToBase64(new TextEncoder().encode("a    ")); // "YSDEgCDwkICAIOaWhyDwn6aE"
	// new TextDecoder().decode(base64ToBytes("YSDEgCDwkICAIOaWhyDwn6aE")); // "a    "
	// Input: base 64 string.
	// Output: Uint8Array which is a binary byte array.
	function base64ToBytes(base64) {
		const binString = atob(base64);
		return Uint8Array.from(binString, (m) => m.codePointAt(0));
	}

	// MDN function
	// Input: Should work on any Array or typed array.
	// Output: Base 64 string.
	function bytesToBase64(bytes) {
		const binString = Array.from(bytes, (byte) =>
			String.fromCodePoint(byte),
		).join("");
		return btoa(binString);
	}

	// Converts an ArrayBuffer into a hex string.
	// Input: buffer is an ArrayBuffer.
	// Output: hex string.
	function buf2hex(buffer) {
		return [...new Uint8Array(buffer)]
			.map(x => x.toString(16).padStart(2, '0'))
			.join('');
	}//buf2hex()

	// Keeping unused function because it is symetrical to a used one.
	// Converts a hex string into an ArrayBuffer.
	// Input: hex string.
	// Output: buffer is an ArrayBuffer.
	function hex2buf(hexString){
		// convert to a number array representing the hex bytes.
		const hexBytesArray = new Array;
		for(let i=0; i < hexString.length; i+=2){
			hexBytesArray.push(parseInt(hexString.substring(i, i+2), 16));
		}
		const hexArrayBuffer = new Uint8Array(hexBytesArray);
		return hexArrayBuffer;
	}//hex2buf()

	/**
	 * Returns a cryptographically secure random integer between min and max, inclusive.
	 * Converted from stackoverflow.
	 *
	 * @param {number} min - the lowest integer in the desired range (inclusive)
	 * @param {number} max - the highest integer in the desired range (inclusive)
	 * @returns {number} Random number
	 */

	function randomInt(min, max){
		const MAX_RANGE_SIZE = 2 ** 53;
		const buffer = new Uint32Array(1024);
		let offset = buffer.length;

		if (!(Number.isSafeInteger(min) && Number.isSafeInteger(max))) {
			throw Error("min and max must be safe integers");
		}
		if (min > max) {
			throw Error("min must be less than or equal to max");
		}
		const rangeSize = max - min + 1;
		if (rangeSize > MAX_RANGE_SIZE) {
			throw Error("(max - min) must be <= Number.MAX_SAFE_INTEGER");
		}
		const rejectionThreshold = MAX_RANGE_SIZE - (MAX_RANGE_SIZE % rangeSize);
		let result;
		do {
			if ((offset + 1) >= buffer.length) {
				crypto.getRandomValues(buffer);
				offset = 0;
			}
			result = (buffer[offset++] & 0x1f_ffff) * 0x1_0000_0000 + buffer[offset++];
		} while (result >= rejectionThreshold);
		return min + result % rangeSize;
	}

	//////////////////////////////////////////
	//				Logging
	//////////////////////////////////////////
	// Global flag starts at false for security and UX.
	let debug_flag = "true";
	// Need to set the //debug() function on page load.
	// Debug mode gets turned off with every page load. This is good for security so leave it.
	setDebug(false);
	// Use a toggle button for usage.
	async function toggleDebug(){
		if( debug_flag === "false"){
			document.getElementById("toggle_debug_button").innerHTML = "Switch to Normal Mode";
			// Toggle global flag.
			debug_flag = "true";
			// Turn on 
			setDebug(true);
			//debug("Debug function activated!");
			//debug("Warning! Plaintext in console to illustrate Data Flow.");
		} else {
			document.getElementById("toggle_debug_button").innerHTML = "Switch to Debug Mode";
			// Toggle global flag.
			debug_flag = "false";
			// Turn off
			setDebug(false);
			//debug("Debug function deactivated! MAJOR ERROR if you can see this! Debug function should be turned off!");
		}
	}

	// Grab currently running HTML and save it to standalone.html
	// This saves the offline dbase in addition to creating and downloading a standalone version that can be used offline.
	function saveOfflineDBase(){
		// This line doesn't get applied with the innerHTML call below so add it manually.
		let allhtml = "<!DOCTYPE HTML>";
		// This will grab a copy of the currently running HTML.
		allhtml += document.querySelector("html").innerHTML;
		//console.log(allhtml);

		let element = document.createElement('a');
		element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(allhtml));
		element.setAttribute('download', 'standalone.html');

		element.style.display = 'none';
		document.body.appendChild(element);

		element.click();

		document.body.removeChild(element);
	}

	// Logging function found on stackoverflow
	// For security, if function setDebug(true) isn't called, //debug(log_message) will do nothing.
	function setDebug(isDebug) {
		if (isDebug) {
			// Turn on warning message.
			const titletext = document.getElementById("titletext");
			titletext.style.color = "red";
			titletext.innerHTML = "DEBUGWORD - CAUTION!!!!<br> SENSITIVE DATA WILL BE SHOWN IN CONSOLE";
			// Send a message to the console.
			window.debug = window.console.log.bind(window.console, '%s');
		} else {
			// Turn off warning message.
			const tffitletext = document.getElementById("titletext");
			titletext.style.color = "#54c597";
			titletext.innerHTML = "SECRETWORD";

			// Do nothing.
			window.debug = function() {};
		}
	}	


</script>

</body>

</html>









