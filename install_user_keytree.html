<!DOCTYPE HTML>
<html>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<style>
* {
    background-color: black;
    color: #03A062;
    font-family: 'Khula', sans-serif;
}

input[type='text'] {
    background-color: darkgrey;
    color: darkred;
}

input[type='button'] {
	background-color: grey;
	color: yellow;
}

input[type='text'][disabled] {
    background-color: #202020;
}

</style>
<body>
	<label>Computed mnemonic:</label>
	<input type='text' id='computed_mnemonic' style='width: 550px;' disabled='true'></input>
	<input type='button' id='compute_mnemonic' onclick='compute_mnemonic()' value='Compute Mnemonic'>
	</input><br>
	<label>Computed seed:</label>
	<input type='text' id='computed_seed' style='width: 550px;' disabled='true'></input>
	<br><br>
	<label>Enter mnemonic:</label>
	<input type='text' id='mnemonic' style='width: 550px;'></input>
	<input type='button' id='go_mnemonic' onclick='install_user_keytree()' value='Save Mnemonic'>
	</input><br>
	<label>Currently saved seed:</label>
	<input type='text' id='current_seed' style='width: 550px;' disabled='true'></input><br>
	<label>Currently saved mnemonic (for initial testing):</label>
	<input type='text' id='current_mnemonic' style='width: 550px;' disabled='true'></input><br>
	<br>
	<label>Enter message from Alice:</label>
	<input type='text' id='message' style='width: 550px;'></input><br>
	<input type='button' id='go_message' onclick='send_message()' value='Send Message'></input><br>
	<label>Alice's private key:</label>
	<input type='text' id='alice_prv' style='width: 550px;' disabled='true'></input><br>
	<label>Alice's public key:</label>
	<input type='text' id='alice_pub' style='width: 550px;' disabled='true'></input><br><br>
	<label>Bob's private key:</label>
	<input type='text' id='bob_prv' style='width: 550px;' disabled='true'></input><br>
	<label>Bob's public key:</label>
	<input type='text' id='bob_pub' style='width: 550px;' disabled='true'></input><br><br>
	<label>Shared secret Alice private key + Bob public key:</label><br>
	<input type='text' id='secret_alice' style='width: 550px;' disabled='true'></input><br>
	<label>Shared secret Bob private key + Alice public key:</label><br>
	<input type='text' id='secret_bob' style='width: 550px;' disabled='true'></input><br><br>
	<label>Alice composed message:</label><br>
	<label>IV (Salt):</label><br>
	<input type='text' id='alice_iv' style='width: 550px;' disabled='true'></input><br>
	<label>C (AES encrypted message):</label><br>
	<input type='text' id='alice_c' style='width: 550px;' disabled='true'></input><br>
	<label>M (HMAC Signature):</label><br>
	<input type='text' id='alice_m' style='width: 550px;' disabled='true'></input><br>
	<label>Alice plaintext to Bob:</label><br>
	<input type='text' id='alice_plaintext' style='width: 550px;' disabled='true'></input><br><br>
	<label>Bob decoded message:</label><br>
	<label>Bob plaintext received by Alice:</label><br>
	<input type='text' id='bob_plaintext' style='width: 550px;' disabled='true'></input><br>
	<label>IV (Salt):</label><br>
	<input type='text' id='bob_iv' style='width: 550px;' disabled='true'></input><br>
	<label>C (AES encrypted message):</label><br>
	<input type='text' id='bob_c' style='width: 550px;' disabled='true'></input><br>
	<label>M (HMAC Signature):</label><br>
	<input type='text' id='bob_m' style='width: 550px;' disabled='true'></input><br>
	<label>Message decrypted by Bob:</label><br>
	<input type='text' id='decrypted_message' style='width: 550px;'></input>


<script src="js_include_files/wordlist_english.js"></script>
<script src="js_include_files/crypto.js"></script>
<script src="js_include_files/noble-secp256k1.js"></script>
<script src="js_include_files/noble-ripemd160.js"></script>
<script>
// Ability check
console.log('test mnemonic word list: ' + wordListArray[1])
// objects to use 3rd party functions
let secp = nobleSecp256k1;
let noble = nobleHashes;

async function send_message(){
	const message = document.getElementById('message').value;
	// hardcode key level for testing, use mnemonic until derive_key_tree function is changed
	mnemonic = document.getElementById('current_mnemonic').value;
	const alice_keys = await derive_key_tree('m/0', mnemonic);
	const alice_prv = alice_keys[0];
	const alice_pub = secp.getPublicKey(alice_prv, true);
	document.getElementById('alice_prv').value = alice_prv;
	document.getElementById('alice_pub').value = alice_pub;

	// super simple implementation to start with, proof of sanity check
	// so, implement all bob stuff here and move later
	// use different key tree indexes which I think should work
	// compute different bob keys for each send
	const bob_mnemonic = await computeMnemonicPhrase();
	const bob_keys = await derive_key_tree('m/1', bob_mnemonic);
	const bob_prv = bob_keys[0];
	const bob_pub = secp.getPublicKey(bob_prv, true);
	document.getElementById('bob_prv').value = bob_prv;
	document.getElementById('bob_pub').value = bob_pub;

	// shared secrets
	const secret_alice = secp.getSharedSecret(alice_prv, bob_pub, true);
	const secret_bob = secp.getSharedSecret(bob_prv, alice_pub, true);
	document.getElementById('secret_alice').value = secret_alice;
	document.getElementById('secret_bob').value = secret_bob;

	// in this function encrypt from alice's point of view
	// get both keys for ease of using function already provied by Len
	const encrypt_and_hmac_keys = await gen_encrypt_and_hmac_keys(secret_alice);
	const message_alice = document.getElementById('message').value;
	const encoded_message_alice = new TextEncoder().encode(message_alice);

	// aes_encrypted.encrypted_message is C
	// aes_encrypted.iv is IV
	// encrypt_and_hmac_keys.encrypt is Ke
	// encrypt_and_hmac_keys.hmac is Km
	const aes_encrypted = await AES_256_CBC_encrypt (encoded_message_alice, encrypt_and_hmac_keys.encrypt);
	console.log('encrypted message: ' + aes_encrypted.encrypted_message);
	document.getElementById('alice_iv').value = aes_encrypted.iv;
	
	// [IV + C]HMAC = M
	const hmac_signature_of_aes_encrypted = await compute_HMAC_SHA256_signature(aes_encrypted.encrypted_message, encrypt_and_hmac_keys.hmac);

	// concatenate before sending over internet
	// IV + C + M
	// first convert everything to hex strings and show for clarity
	const iv_hex = buf2hex(aes_encrypted.iv);
	const c_hex = buf2hex(aes_encrypted.encrypted_message);
	const m_hex = buf2hex(hmac_signature_of_aes_encrypted);
	document.getElementById('alice_iv').value = iv_hex;
	document.getElementById('alice_c').value = c_hex;
	document.getElementById('alice_m').value = m_hex;
	console.log('iv length' + iv_hex.length); //32
	console.log('m length' + m_hex.length);		//64
	
	// plaintext(IV+C+M)
	const alice_sent_payload = iv_hex + c_hex + m_hex;
	document.getElementById('alice_plaintext').value = alice_sent_payload;

	// send message to bob
	const bob_received_payload = alice_sent_payload;
	document.getElementById('bob_plaintext').value = bob_received_payload;
	const iv_hex_bob = bob_received_payload.slice(0, 32);
	const c_hex_bob = bob_received_payload.slice(32, -64);
	const m_hex_bob = bob_received_payload.slice(-64);
	document.getElementById('bob_iv').value = iv_hex_bob;
	document.getElementById('bob_c').value = c_hex_bob;
	document.getElementById('bob_m').value = m_hex_bob;



	// start decrypt
	// keep for sanity/confidence
	const returned = await decrypt_message(aes_encrypted.encrypted_message, aes_encrypted.iv);
}

// in this function decrypt from bob's point of view
async function decrypt_message(encrypted_message, iv){
	const secret_bob = document.getElementById('secret_bob').value;

	const encrypt_and_hmac_keys = await gen_encrypt_and_hmac_keys(secret_bob);

	//const encrypted_message = document.getElementById('encrypted_message').value;
	//const iv = document.getElementById('iv').value;
	//const encoded_encrypted_message = new TextEncoder().encode(encrypted_message);
	const decrypted_message = await AES_256_CBC_decrypt (encrypted_message, encrypt_and_hmac_keys.encrypt, iv);
	const decrypted_message_decoded = new TextDecoder().decode(decrypted_message);
	document.getElementById('decrypted_message').value = decrypted_message_decoded;
	return 0;
}

// inspired by Len's function
// returns an associative array of the keys
async function gen_encrypt_and_hmac_keys( sharedSecretKey ){
    //Check to ensure that input appears to be a 33-byte hex compressed public key.
    if (sharedSecretKey.length != 66) {
        console.log('WARNING: provided shared secret is not compressed hex public key');
    }
    //Array buffer holds 32 bytes, with each index being one byte.
    const sharedSecretArrayBuffer = hex_string_to_ArrayBuffer(sharedSecretKey);
    const sha512SharedSecret = await window.crypto.subtle.digest('SHA-512', sharedSecretArrayBuffer);
    const encryptKey32ByteArrayBuffer = sha512SharedSecret.slice(0, 32);
    const hmacKey32ByteArrayBuffer = sha512SharedSecret.slice(32, 64);

    //Converts ArrayBuffer keys into CryptoKey objects.
    const encrypt_CryptoKey = await crypto.subtle.importKey(
        "raw",
        encryptKey32ByteArrayBuffer,
        "AES-CBC",
        false, //Key is not extractable. Already shared through ECDH.
        ["encrypt", "decrypt"] //Approved for encryption/decryption.
    );
    const hmac_CryptoKey = await crypto.subtle.importKey(
        "raw",
        hmacKey32ByteArrayBuffer,
        {name:"HMAC", hash: {name:"SHA-256"}},
        false, //Key is not extractable. Already shared through ECDH.
        ["sign", "verify"] //Approved for encryption/decryption.
    );

    return { encrypt: encrypt_CryptoKey, hmac: hmac_CryptoKey };

}

//Decrypts a plaintext message with AES-256-CBC with the given key.
//Encrypted message is an ArrayBuffer.
//Key is a CryptoKey object.
//aes_256_iv is ...
//Decrypted message is an ArrayBuffer.
async function AES_256_CBC_decrypt (encrypted_message, key, aes_256_iv) {
    const plaintext = await window.crypto.subtle.decrypt(
        { name: "AES-CBC", iv: aes_256_iv  },
        key,
        encrypted_message
    );
    return plaintext;
}

//Encrypts a plaintext message with AES-256-CBC with the given key.
//Plaintext message is an ArrayBuffer.
//Key is a CryptoKey object.
//Encrypted message is an ArrayBuffer.
async function AES_256_CBC_encrypt (plaintext_message, key) {
    const aes_256_iv = generate_AES_256_CBC_IV();
    const ciphertext = await window.crypto.subtle.encrypt(
        { name: "AES-CBC", iv: aes_256_iv  },
        key,
        plaintext_message
    );
    return { encrypted_message: ciphertext, iv: aes_256_iv };
}

// Produce HMAC signature 
// data is the data to be hashed/signed
// key is the key in which is doing the signing
async function compute_HMAC_SHA256_signature (data, key){
	const signature = await window.crypto.subtle.sign(
		"HMAC",
		key,
		data
	);
	return signature;
}



//Generate a random 16 byte IV for use with AES-256-CBC encryption.
function generate_AES_256_CBC_IV() {
    return window.crypto.getRandomValues(new Uint8Array(16))
}

// outputs seed which is saved to localStorage.
async function install_user_keytree(){
	const mnemonic = document.getElementById('mnemonic').value;
	//const password = document.getElementById('password').value;
	// test mnemonic validity console.log error phrases to be handled differently.
    if( await verifyMnemonicPhrase(mnemonic) ){
		console.log('Mnemonic verified.');
		//const seed = await computeSeed512(mnemonic, password); add pw later.
		const seed = await computeSeed512(mnemonic);
		console.log('computed seed: ' + seed);
		// Save seed in browser 
		if (typeof(Storage) !== "undefined") {
			if (localStorage.seed) {
				console.log('Overwriting previously saved seed. Old seed: ' + localStorage.seed);
				localStorage.seed = seed;
			} else {
				console.log('Saving seed for the first time.');
				localStorage.seed = seed;
			}
		} else {
			console.log("Sorry, your browser does not support web storage...");
		}
		document.getElementById('current_seed').value = localStorage.seed;
		document.getElementById('current_mnemonic').value = mnemonic;
    }else if( mnemonic.split(' ').length != 12){
        console.log('This generator only takes mnemonic sentences of 12 words.');
    }else{
        console.log('Mnemonic sentence INVALID! Please enter a valid phrase');
    }
}

// load seed if there is one
window.onload = function(){
	document.getElementById('current_seed').value = localStorage.seed;
}

async function compute_mnemonic(){
	const computed_mnemonic = await computeMnemonicPhrase();
	document.getElementById('computed_mnemonic').value = computed_mnemonic;
	document.getElementById('computed_seed').value = await computeSeed512(computed_mnemonic);
}

</script>

</body>

</html>
