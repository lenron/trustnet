<!DOCTYPE HTML>
<html>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<body>
<script src="wordlist_english.js"></script>
<script>
console.log(wordListArray[0])

// Set of base58 chars
const base58 = [
      1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
];
console.log('1: ' + base58[0]);
console.log('check A: ' + base58[9]);
// set of base58 chars looks to be working. moving on...

// can't read len's perl code, moving to python implementation I found:
// https://rosettacode.org/wiki/Base58Check_encoding#Python
//result = '';
//num = 60;
//r = num % 58;
//console.log('r, should be 2: ' + r);

//check this number is correct:
console.log('0x61: ' + Number('0x61'));
console.log('0x61: ' + convert_to_base58(Number('0x61')));
console.log('0x10c8511e ' + convert_to_base58(Number('0x10c8511e')));
function convert_to_base58(num){
	result = '';
	var r = ''
	var sb = '';
	while(num > 0){
		r = num % 58;
		sb = sb + base58[r];
		num = Math.floor(num/58);
		console.log('num: ' + num);
	}
	return sb.split('').reverse().join('');;
}
//Looks like the converter works!~


function base58check(payload_data, versionByte){
//Take the version byte and payload bytes, and concatenate them together (bytewise).
//Take the first four bytes of SHA256(SHA256(results of step 1))
//Concatenate the results of step 1 and the results of step 2 together (bytewise).
//Treating the results of step 3 - a series of bytes - as a single big-endian bignumber, convert to base-58 using normal mathematical steps (bignumber division) and the base-58 alphabet described below. The result should be normalized to not have any leading base-58 zeroes (character '1').
//The leading character '1', which has a value of zero in base58, is reserved for representing an entire leading zero byte, as when it is in a leading position, has no value as a base-58 symbol. There can be one or more leading '1's when necessary to represent one or more leading zero bytes. Count the number of leading zero bytes that were the result of step 3 (for old Bitcoin addresses, there will always be at least one for the version/application byte; for new addresses, there will never be any). Each leading zero byte shall be represented by its own character '1' in the final result.
//Concatenate the 1's from step 5 with the results of step 4. This is the Base58Check result.

}


</script>
</body>
</html>












